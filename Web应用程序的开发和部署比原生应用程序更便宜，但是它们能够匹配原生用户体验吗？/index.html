<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="刘毅 halohily@hotmail.com"><title>移动应用程序开发：Web VS. 原生(译) · 刘毅的个人博客。</title><meta name="description" content="原文《mobile application Development: Web vs. native》,是由Andre Charland和Brian Leroux发布在《Communications of the Acm》的文章，深入探讨了移动领域Web开发和原生开发相关的问题。截止翻译，引用量320"><meta name="keywords" content="Hexo,iOS,Github,Python,JavaScript,Objective-C"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">刘毅的个人博客。</a></h3><div class="description"><p>iOS开发者，正在探索大前端</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/http://www.weibo.com/3656155132/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/https://github.com/halohily"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/avatar.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>移动应用程序开发：Web VS. 原生(译)</a></h3></div><div class="post-content"><blockquote>
<p>原文<a href="http://delivery.acm.org/10.1145/1950000/1941504/p49-charland.pdf?ip=219.143.205.19&amp;id=1941504&amp;acc=OPEN&amp;key=BF85BBA5741FDC6E%2EC98212438850C910%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;CFID=937521874&amp;CFTOKEN=13274010&amp;__acm__=1495019995_a85a3f4149c41338291e079156c05b2d" target="_blank" rel="external">《mobile application Development: Web vs. native》</a>,是由<code>Andre Charland</code>和<code>Brian Leroux</code>发布在<code>《Communications of the Acm》</code>的文章，深入探讨了移动领域Web开发和原生开发相关的问题。截止翻译，引用量<code>320</code>。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Web应用程序的开发和部署比原生应用程序更便宜，但是它们能够匹配原生用户体验吗？</div></pre></td></tr></table></figure>
<h1 id="移动应用程序开发：Web-VS-原生"><a href="#移动应用程序开发：Web-VS-原生" class="headerlink" title="移动应用程序开发：Web VS. 原生"></a>移动应用程序开发：Web VS. 原生</h1><p>　　短短几年前，大多数的移动设备，想要使用一个更贴切的词语来形容，是“哑的”。当然，也有一些早期的智能手机，但是他们要么是邮件集中，要么就是缺乏一个可以不用小尖笔就可以使用的先进触摸屏。附带一个有能力显示任何东西，不止是简单的文本，链接，或者是一个图像的像样的手机浏览器的就更少了.这意味着如果你有这些设备之一，你要么是一个沉迷于电子邮件的商人，要么是一个希望这是智能手机之年的最初的极客。之后苹果用<code>iPhone</code>的发布改变了一切，同时我们对于移动设备使用体验的预期被完全重设。</p>
<p>　　最初对于第三方<code>iPhone</code>应用程序的计划是使用开放的<code>Web</code>技术。苹果甚至为它的<code>Dashcode</code>项目发布了工具。快速向前发展的三年，原生应用程序大大流行。通常，就工作性能的原因来看，相比较来说移动<code>Web</code>正在变得不是最适宜的。</p>
<p>　　顺着这一条思考的路线有两个问题。首先，如果使用各自的原生语言来为不同平台构建应用程序是非常昂贵的。一个独立游戏开发者或者启动很有可能只可以支持一种设备，就像<code>iPhone</code>，但是一个IT部门必须支持它的用户的所有设备，即使它们不总是最新的和最好的。第二，原生应用程序适用于<code>3D</code>游戏或者图像处理时更快速的性能表现相关的争论，而且在一个使用<code>Web</code>技术良好构建的商业应用中有微小的、不引人注意的性能损失。</p>
<p>　　就其本身而言，<code>谷歌</code>正在为使用<code>Web</code>技术去解决平台分裂化问题押注。<code>谷歌</code>负责工程的副总裁，声称</p>
<blockquote>
<p>“连谷歌也没有足够的钱去支持所有的不同的移动平台—从<code>苹果的应用程序商店</code>到<code>黑莓</code>、<code>Windows移动操作系统</code>、<code>安卓，</code>以及<code>诺基亚平台</code>的许多变种”。并且这是在<code>惠普Web操作系统</code>、<code>MeeGo</code>和其他平台问世之前。</p>
</blockquote>
<p>　　在本文中，我们讨论Web和原生方法的一些优势和缺点，伴随着对于Web技术和它对应的原生同作用事务之间沟壑正在缩小的领域的特别关注。</p>
<h3 id="原生代码-VS-Web代码"><a href="#原生代码-VS-Web代码" class="headerlink" title="原生代码 VS. Web代码"></a>原生代码 VS. Web代码</h3><p>　　实现一个软件应用程序从代码开始。在原生代码的情况下，大多数时候开发者通常用<code>C语言</code>系列，就像在开发<code>iPhone应用程序</code>的情况下。在我们在<a href="http://nitobi.com/" target="_blank" rel="external">Nitobi</a>和<a href="http://www.phonegap.com/" target="_blank" rel="external">PhoneGap</a>上的工作中，我们已经有足够的经验从一个原生开发者的角度去应对多样变化的移动平台。</p>
<p>　　当然，由于多样变化的市场，或者是由于组织化的原因，大多数的开发者或者团队必须支持多个智能手机平台的应用程序。想要用原生代码写一个应用程序然后面对每一个单独的移动操作系统？没有问题，如果你的团队具有附带表格所展示的技能集。</p>
<p>　　使事情变得更复杂的是实际的平台开发工具集之间的不同。有不同的工具、构建系统、应用程序编程接口，以及对于每个平台有不同能力的设备。事实上，这些操作系统共同拥有的唯一事物是它们都附带一个可以编程化访问原生代码的移动浏览器。</p>
<p>　　每个平台都允许我们实例化一个浏览器实例，更简洁，并且可以使用它的<code>JavaScript</code>接口与原生代码相互配合。从<code>Webview</code>中我们可以通过<code>JavaScript</code>调用原生代码。这种攻击作为<code>PhoneGap</code>技术开始成名，由<code>Eric Oesterle</code>，<code>Rob Ellis</code>和<code>Brock</code>开创，于2008年在<code>iPhone开发营</code>为<code>iPhone操作系统</code>下开发工具集而写。这种方法后来被移植到<code>安卓</code>、<code>黑莓</code>，以及其他支持<code>PhoneGap</code>的平台。<code>PhoneGap</code>是一个开源的框架，它提供给开发者一个他们可以使用<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>来开发移动应用程序的环境，并且仍然可以通过通用的<code>JavaScript</code>接口调用原生的<code>设备特性</code>和<code>传感器</code>。<code>PhoneGap</code>框架包含原生代码片段，用来和底层操作系统互相配合以及传递信息给运行在<code>Webview</code>容器中的<code>JavaScript</code>应用程序。如今，有对地理定位、加速度计的支持，以及其他的许多。</p>
<p>　　那么原生代码到底是什么？它通常是编译型语言，比解释型语言例如<code>JavaScript</code>运行得更快。<code>Webview</code>浏览器使用<code>HTML</code>和<code>CSS</code>构建用户界面，具有不同程度的能力和成功。使用原生代码，我们可以通过专有的应用程序编程接口直接在屏幕上绘制像素，还可以抽象化通用的用户界面元素和控件。</p>
<p>　　简而言之，我们在让<code>JavaScript</code>和编译型语言较量。如今，<code>JavaScript</code>持有它自己。这并不令人惊异——<code>JavaScript</code>虚拟机技术是如今新的浏览器战争的前线。<code>微软</code>、<code>谷歌</code>、<code>苹果</code>、<code>Opera</code>和<code>Mozilla</code>都在激烈地反复迭代，竞争着完成实现。现在，通过一些<a href="http:// arewefastyet.com/" target="_blank" rel="external">基准</a>，<code>Mozilla</code>的<code>”蜘蛛-猴子“</code>正在接近谷歌的<code>V8引擎</code>。苹果的<code>JavaScriptCore</code>，在大多数的<code>WebKit</code>浏览器（使用于数量最多的移动设备上）中建立，并介于其中。底线是所有主要参与者的沉重开支正在为这场JavaScript军备竞赛添火加柴。<code>Ars Technica</code>的基准图1是这些企业是如何推销自己的一个例子。</p>
<p>　　<code>JavaScript</code>正在迅速地变得更快——如此得快，事实上，惠普的<code>Palm Web操作系统</code>2.0版本重写了它的服务层，原来是<code>Java</code>，现在是极其受欢迎的<a href="http://nodejs.org/" target="_blank" rel="external">node.js平台</a>，它是构建于谷歌的V8引擎上并且在更低的<code>CPU</code>消耗下有更好的性能表现（因此具有更长的电池使用时间）。我们所能见到的趋势是<code>Web</code>技术栈运行在低水平，并且相应地在今天数以百万计的设备上。</p>
<h3 id="用户界面代码"><a href="#用户界面代码" class="headerlink" title="用户界面代码"></a>用户界面代码</h3><p>　　当谈到用户界面时，事情并不那么美好。大多数原生平台有通用用户界面控件和体验的极好的抽象。没有两个平台有一样的，甚至相似的用户界面模式，更不用说单独使用应用程序编程接口去实例化和访问它们。Web平台在大多数情况下是一致的，但是内建的或者开发工具集包含的控件的数量是有限的。你必须去自己开始工作。有时浏览器之间的不同会造成烦恼，但是至少在现代智能手机的世界中，大多数设备运行着最能干<code>WebKit</code>渲染引擎，而且它们之间只有微小的差异。</p>
<p>　　不幸的是，对于Web来说，那些微小的差异正在变成大问题。举个例子，在<code>iOS</code>中，<code>CSS位置</code>属性不能正确地支持一个<code>“xed”</code>的值。（这曾是安卓中的一个问题，但是已经在最新的安卓2.2代码中被修正。）黑莓操作系统在6.0版本之前运行着一个完全神秘的浏览器，对于Web开发人员的心智健康造成很多辛劳，也遭受很多痛苦。幸运的是，<code>RIM</code>在6.0版本中已经解决了很多类似的事情，并且一般来说，事情会变得越来越好。</p>
<p>　　一些操作系统包含一些叫做<code>硬件加速</code>的事物。iOS堆栈非常著名地支持了这个<code>CSS转换</code>的概念，这是关于Web框架如何顺畅地在视图状态之间转换。这是一个首先在<code>Dashcode</code>中被发明的技术。它由<code>David Kaneda</code>煞费苦心地反向工程化，在<a href="http://jqtouch. com/" target="_blank" rel="external">jQTouch</a>上开创，并且后来在<a href="http://www.sencha.com/" target="_blank" rel="external">Sencha Touch</a>发布。它们都是令人难以置信的Web项目，同时也是当开发人员推动边界时什么事情可以被完成的例子。</p>
<p>　　当我们首先开始利用这些下一代的移动浏览器时，没有什么框架可以在不同设备之间正确地工作。如今有超过20种的移动框架，并且相关支持正在被快速地添加到已有的<code>文档对象模型</code>库中——不止是<code>John Resig</code>的<a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>，还有<a href="http://jquerymobile. com/" target="_blank" rel="external">jQuery移动版</a>；那些代码正在被不断地完善，并且每天都在为更多的设备添加支持。有了这些类似的工具，从一个单独的面向Web的代码库去支持多个目标变得越来越容易。</p>
<p>　　当把Web技术栈和原生代码比较时，快速执行和漂亮的用户界面并不是故事的全部。Web技术存在于<code>沙盒</code>，这也是原生代码可以访问的低级API的笼子——可以访问设备存储、传感器和数据的API。但是这一沟壑也正在被弥合。如今大多数移动浏览器支持地理定位，举个例子，iOS最近增加了加速度计和一些其他的HTML5应用程序编程接口。考虑到W3C有一个<a href="http:// www.w3.org/2009/dap/" target="_blank" rel="external">设备API工作组</a>，就好像我们在不久的将来将会看到许多连至浏览器的API。如果这个很近的将来不是足够短的话，现在你可以使用<a href="http://docs.phonegap. com/" target="_blank" rel="external">PhoneGap</a>来获取这些API。</p>
<p>　　当然，Web技术堆栈(<code>HTML/CSS/JS</code>)本身就是用原生代码实现的。原生层和浏览器之间的距离就只是一个编译而已。换句话说，如果你想给一个浏览器添加一个原生的能力，你也可以桥接它或者重新编译这个浏览器以获得那个能力。如果一个浏览器不支持一个原生的能力，不是因为它确实不能，也不是因为它不愿意；它只是意味着它尚未完成。</p>
<h3 id="用户体验：上下文环境与实现"><a href="#用户体验：上下文环境与实现" class="headerlink" title="用户体验：上下文环境与实现"></a>用户体验：上下文环境与实现</h3><p>　　另一个对原生和Web移动应用程序开发都有重大影响的领域是用户体验，我们使用这个术语来描述用户使用一个软件应用程序期间的全面的体验。用户体验甚至可以扩展到应用程序之外。举个例子，我们在某些情况下发送通知去唤醒一个应用程序，比如一个地理位置的变化，或者产生一个专用的应用程序去处理不同的应用方面。显然，一个成功的用户体验是采用成功应用的关键。</p>
<p>　　一般来说，一个移动软件项目的用户体验可以分为两个主要类别：</p>
<ul>
<li><strong>环境</strong></li>
</ul>
<p>　　元素必须能够被理解，但是不能被改变或者被控制。这些包括硬件功能，平台能力和用户界面规范，以及应用程序被使用的环境。</p>
<ul>
<li><strong>实现</strong></li>
</ul>
<p>　　在一个应用程序中可以被控制的元素，比如性能，设计以及集成平台特性，例如加速度计的数据或者通知。</p>
<p>　　你的应用程序将被使用的<strong>环境</strong>影响着用户的预期。单独的应用的使用环境可能和一个用户与用户之间互相影响的应用或者一个单独的平台完全不同。我们其实不是在谈论一个环境；我们在谈论多个环境。让我们看看定义一个成功的移动应用程序必须具备的环境的东西究竟有什么。</p>
<p>　　<strong>硬件</strong>。安卓设备的生态系统是一个多样化环境的极好的例子，设备在显示的多方面（物理尺寸、颜色深度、屏幕分辨率、像素密度、长宽比）、输入（轨迹球、触摸屏、物理键盘、麦克风和摄像头）以及能力方面（处理能力、存储、天线等等）显著多样化。</p>
<p>　　这些属性的结合极大地影响着你的应用程序将如何展示，以及用户可能选择的与它交互的方法的范围。如果如今不存在一个特定的组合，明天也将很有可能出现。一个成功的应用程序必须考虑所有这些硬件设备相关的习惯。</p>
<p>　　<strong>平台的约定</strong>。每个平台都有它自己的用户界面约定，通常在人机界面指南文档中描述，在操作系统界面证实。移动Web浏览器的多样性提供了一个典型的例子来展示这些约定可以是怎么样得不同：</p>
<p>　　一个公共的用户期望是浏览器中“返回”的能力。iOS使用一个虚拟按钮来实现它；安卓和黑莓设备依赖一个物理实体返回按钮；Web操作系统使用一个返回按钮和一个返回手势。无论方法是什么，用户希望在你的应用程序中他们可以“返回”。</p>
<p>　　用户也期望一个环境菜单。在安卓和黑莓的默认浏览器中，环境菜单通过一个被设立在屏幕底部的物理按键打开，接近拇指的自然的位置。在iOS和Web操作系统中环境菜单通过位于屏幕底部靠近拇指固定存在的虚拟标签栏来打开。这个固定存在于屏幕底部的标签栏在非iOS和Web OS设备中经常产生一个很差的体验因为用户会很容易地误触他们的环境菜单或者返回按钮，造成应用程序意外地被关闭。这些是原生和Web应用程序都必须考虑的限制。</p>
<p>　　开发人员必须考虑对数据和用户都有良好意义的方法。<code>HTML5</code>不支持菜单元素的概念，所以一个通用的抽象在这里就是可行的，但是它尚未完成。</p>
<p>　　<strong>环境</strong>是最大的不确定因素。现在是白天还是夜晚？用户在站着还是坐着？站定还是移动中？一个手空闲还是两个手？在一个繁忙的地方吗？可变性是无限的。</p>
<p>　　它指引着我们什么方向？从环境中传出来的期望并不是天生跨平台的。原生和Web实现都必须提供设计和代码去支持这些期望。对于Web开发人员来说好消息是他们可以依靠一个熟悉模式在Web技术堆栈中满足用户期望。</p>
<p>　　<strong>实现</strong>。为了产生最优的可行的用户体验，实现部分必须在设计和代码上兼顾支持由一个特定的用户环境产生的期望。</p>
<h3 id="性能：软件开发的妖怪"><a href="#性能：软件开发的妖怪" class="headerlink" title="性能：软件开发的妖怪"></a><strong>性能：软件开发的妖怪</strong></h3><p>　　毫无疑问，性能是一份良好用户体验的基石。就像安全性，它是最被误解的，也是软件开发人员的限制使用的替罪羊。不难听到开发人员拒绝一份想法的同时碎碎念：“我们不能这么做，这会对性能造成负面影响。”很少量化，但频繁地引用着一句话：“性能是软件开发的妖怪。”我们如何量化性能？延迟是性能的一种形式。执行，一个操作完成需要的时间，是另一种。我们会分开解决这些事情。</p>
<p>　　在移动开发世界中，延迟是一个重要的考虑点。不管它是原生应用程序还是一个Web应用程序，在下载一个应用程序以及它通过网络耗费或发布数据时，都会有性能损失。显然，负载越小，应用程序越快速。</p>
<p>　　使用<code>JavaScript对象表示法</code>（<code>JSON</code>）格式的数据是一个很棒的想法，因为与一个等价的<code>XML</code>负载相比较来说，它会导致更少的数据负载，这取决于XML是如何格式化的。在另一方面，当我们要返回插入Web页面的HTML代码片段，使用XML形式的数据，而非返回JSON形式的数据，当线路较短时，需要使用JavaScript去转换成HTML片段。你面对的情形会不尽相同。基准测试是唯一可以确定结果的方式。</p>
<p>　　另一个延迟问题是代码初始化时。一旦我们将代码写入内存，它就持续地需要被解析。在这个过程中会有明显的性能损失。我们可以仿造它，并且使用确定或不确定的过程指标来提高对性能的感知。</p>
<p>　　执行时间，当然，是一个性能的关键指标。解释执行代码（就像我们为Web使用JavaScript）时，有越多的代码需要解释执行，执行时间就越长。Web技术堆栈中还有一些事情需要追赶着去做。JavaScript，它的所有性能的飞跃，仍然比原生的组件要慢。另一方面，一个程序员为了多种移动设备，使用原生的编译型语言去书写类似的逻辑所花费的时间可能是值得的，相对执行时的损耗来说；然而，这实实在在需要更多的维护，相比起使用JavaScript书写，可在多种设备运行的代码来说，同时也许每个平台需要些许调整。更少的代码通常意味着更少和更容易的维护。</p>
<p>　　有一句话这么讲：“代码的少量对于期待一个良好界面的终端用户来说是无关紧要的。”开发人员的权衡有一个巨大的代码基础，经常容易变得更大，考虑到对多个原生平台的支持。在原生代码的世界中，最大的挑战是重复实现多个目标。在Web的世界中，最大的挑战是尽可能多地限制你的足迹，以产生良好的用户体验。这并不是说一个用户界面可以满足所有的环境。而是，应用程序逻辑的主体在一份代码基础中，然后特定的设备、特定的UI习语可以使用情景化的代码来实现。因此你可以实现不同的功能和用户体验，以适应某个特定设备用户的期望。举个例子，安卓和黑莓设备有物理实体的返回、菜单按钮，而这个iOS设备并没有。</p>
<p>　　另一个需要记住的重点是即使移动设备工业正在快速的汇集于Web开发工具集，即标准的HTML渲染引擎，每种设备和操作系统都有一个稍微不同的WebKit风格。这意味着你应该期待开发变得和如今的跨浏览器Web开发相似。值得庆幸的是，有许多类库例如<code>jQuery移动</code>、<code>Sencha Touch</code>, 和<code>SproutCore</code>在试图解决这个问题。</p>
<p>　　所有关于代码延迟和执行的讨论意味着要对你的应用开发主动性的商业目标采取强硬的态度。支持数据装饰是最实用的方法。渐变、阴影、凹凸变化、压花、高亮、圆角以及柏林噪音并不能使应用的可用性增强——它们并不满足商业要求，但他们影响性能。特别是<code>CSS渐变</code>，是移动世界中真正的魔鬼。你需要决定你的目标是什么：看起来整洁还是为数据发布、获取提供一个有用的界面。你在一些平台上通过使用原生代码优化（通常是硬件加速）像素绘制胜过了这些能力中的一部分。这并不是说这些影响不可能实现，而是说他们被明智地使用，也就是当他们能提升、并且不分离用户体验时。提供一个在市场上获得成功的用户体验是有可能的；要求的仅仅是合适的移动开发技术，以及考虑了环境约束的良好的用户体验设计技巧。</p>
<h3 id="可爱的反弹和美丽的设计"><a href="#可爱的反弹和美丽的设计" class="headerlink" title="可爱的反弹和美丽的设计"></a><strong>可爱的反弹和美丽的设计</strong></h3><p>　　当然，美丽的设计很重要。从美学到无形资产，例如一个良好程序的结构，软件设计者必须致力于伟大的设计，并且立足于已经到位的实践。通过动力学物理滑动，可爱的反弹，放松，并且基于此构建有活力的用户界面，它是令人觉得真实的，并且使用它是一件乐事。这是一个原生控制特别良好的领域。</p>
<p>　　我们还没有使用Web技术圆满地解决原生的滑动问题。但是已经有了许多的尝试：<a href="http://cubiq. org/iscroll" target="_blank" rel="external">iScroll</a>, <a href="http://uxebu. com/blog/2010/04/27/touchscroll-a- scrolling-layer-for-webkit-mobile/" target="_blank" rel="external">TouchScroll</a>, <a href="https://github.com/purple- cabbage/GloveBox" target="_blank" rel="external">GloveBox</a>, <a href="http:// www.sencha.com/" target="_blank" rel="external">Sencha</a>, 以及<a href="http://jquerymobile.com/" target="_blank" rel="external">jQuery Mobile</a>. 所有这些都致力于解决滑动的问题，但是并没有像原生设备一样那样良好地解决。甚至谷歌的移动团队也在致力于发布一个这个问题的解决办法。毋庸置疑，这是<code>PhoneGap</code>团队最常听到的抱怨，在WebKit出现这个问题之前很久我们就已经是它的问题修复者。谷歌移动团队最近已经发布了基于浏览器和平台的WebKit的解决方式以及代码。</p>
<p>　　这是纲要。Web技术栈还没有能够达到原生代码可以获得的优良性能表现级别，但正在逐步接近。我们有自信Web技术将会逐渐无区别于原生体验。同时，Web开发者必须在专注于交付数据的同时提高装饰的工作能力。</p>
<h3 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a><strong>展望未来</strong></h3><p>　　Web和原生在这场辩论中对抗彼此越多，导致的结果很可能是混合的解决方案。或许我们将会看到计算机固有的网络化并且（这是我个人的真诚希望）对于任何人都可以免费访问。我们已经看到原生Web的迹象：<code>WebGL</code>最近证实浏览器运行3D游戏是可行的，甚至运行<a href="http://media.tojicode.com/ q3bsp/" target="_blank" rel="external">Quake III</a>!</p>
<p>　　同时，软件制造商必须平衡Web和原生的对抗，在软件主要的目标、开发、商业现实以及Web技术在不久将来可以提供的机会的基础上。好消息是直到所有技术都被整合进浏览器之前，诸如PhoneGap这类的机构可以帮助弥合鸿沟。我鼓励开发人员不要简单地定义软件开发的趋势，而是实现他们！如果Web不满足你的程序所特定需求的能力，你就获得了一个令人激动的做出贡献的机会，为了弥合Web和原生之间鸿沟的过程做出贡献。</p>
<p><em>译文：Halo</em></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-14</span><i class="fa fa-tag"></i><a href="/categories/文献翻译/" title="文献翻译" class="tag">文献翻译 </a><a href="/tags/移动开发/" title="移动开发" class="tag">移动开发 </a><a href="/tags/原生开发/" title="原生开发" class="tag">原生开发 </a><a href="/tags/Web开发/" title="Web开发" class="tag">Web开发 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,https://halohily.com/Web应用程序的开发和部署比原生应用程序更便宜，但是它们能够匹配原生用户体验吗？/,刘毅的个人博客。,移动应用程序开发：Web VS. 原生(译),;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/Epoch代码+分析/" title="「iOS」行车服务app 「客户端、后端思路+代码」" class="btn">Post Anterior</a></li><li class="next pagbuttons"><a role="navigation" href="/让你的图片加载姿势更优美- iOS图片加载的优化/" title="让你的图片加载姿势更优美- iOS图片加载的优化" class="btn">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>