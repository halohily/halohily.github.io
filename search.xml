<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[关于聊天记录，微信到底有没有说谎]]></title>
      <url>%2F2017%2F10%2F02%2F%E5%85%B3%E4%BA%8E%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%BE%AE%E4%BF%A1%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%A1%E6%9C%89%E8%AF%B4%E8%B0%8E%2F</url>
      <content type="text"><![CDATA[前段时间，有“真正的粉丝”偶然发现，在微信中发送前伟大领导人的照片，接收方毫无回应。查看各自手机发现，发送方显示消息发送成功，而接收方则没有收到消息，也没有任何提示。也就是说，微信知道我们在发送该照片，并且做出了如此处理。 九月份薛之谦和李雨桐的风波刚刚稍微冷却，关于薛之谦晒出的微信聊天记录真伪引发了广泛讨论。如果两人的纠纷进行到诉讼阶段，会是怎样的情形？在我国《民事诉讼法》中明确表示了“电子数据”是证据的一种，而微信聊天记录属于电子数据。但是必须保证聊天双方为当事人、聊天记录真实、完整（未被删减）。有吃瓜群众表示，使用行政手段要求微信官方提供两人的聊天记录，不就没这些问题了吗。且不说这是否合法，单是从技术角度，微信给出回应了：微信聊天数据为用户间点对点传输，腾讯并不会持有用户聊天数据，所以无法提供。 微信宣称没有用户的聊天数据，但是却又知道用户在发送一些政治敏感的内容，那么关于用户的聊天记录，微信到底有没有说谎呢？下面本文单从技术角度来进行几点讨论，为质疑隐私被侵犯的用户提供一些借鉴。 1.微信聊天数据的体量新浪微博官方数据：2016年，微博月活跃用户数全年净增7700万，达3.13亿。而微信的数据则是：截止到2016年12月，微信全球共计8.89亿月活用户。 微博的用户中，内容产出比例并不高。有的人每天都看微博，但是从来不会发微博。有的人会发微博，但是几天一条的频率。仅是在这种情景下，微博的数据量已经使得新浪成长为国内实力强大的大数据处理厂商。而微信的核心功能是聊天，所以在微信中，我们每个人都是极高频率的内容产出者。所以微信的数据量，是比微博的数据量大得多的。事实上，从微信问世到如今，一共产生了多么庞大的聊天记录数据量，我已经很难估计。在这种规模的数据下，微信官方想要进行存储，甚至要进行内容的分析，目前的大数据处理技术应该是不足以应对的。 2.点对点传输的含义我发了一条微博，首先会发送到微博的服务器并且被记录，然后其他用户刷新微博，从微博服务器请求到最新的微博数据，从而看到了我发的微博。信息是点对面的，由微博的服务器进行分发。这样微博官方当然会有关于我这条微博的各种详细数据。而微信聊天时，并不需要官方的服务器作数据的中转存储、下发。我发送一条信息，它被直接发送到了你的手机，信息点对点传送，这样微信官方不便于存储，也没有必要存储我的聊天信息，就可以完成本次聊天。这样看来，微信官方的说法是合理的。 3.微信如何做到屏蔽掉我的信息有的同学会问，“既然微信没有我的聊天数据，那么如何知道我在发送敏感信息呢？” 事实上，数据可以在本地被校验。我们在聊天框中输入的内容，在发送前，经过客户端本地的（也就是你知道是什么内容，微信这个程序也知道，但是微信官方不知道）数据校验，如果被判定为敏感信息，则做特殊处理，造成上文中“我以为我发出去了”的假象。 这样，微信可以做到在不知道我们发送的内容的情况下，对敏感信息进行屏蔽。 4.在微信发送了反动言论，被调查？之前的新闻：“小伙在微信冒充恐怖组织成员，在微信群内开玩笑被拘留”。先不说被举报的可能性，微信是如何知道他在冒充恐怖组织成员呢？而且有人会问，你不是说微信不知道他在发什么吗？ 在移动客户端中，有一个词叫做“埋点”。形象一点解释就是，对用户可能会进行操作的所有情景进行标记，如果在首页位置程序崩溃了，客户端会报告服务器“我在用户点击首页时崩溃了”，在上传头像时崩溃了，客户端报告：”我在上传头像时崩溃了“。统计每一次的崩溃信息，可以帮助开发人员定位问题所在，从而进行改进。 同理，微信也可以在本地校验聊天数据时，进行埋点。当发现用户发送敏感信息时，向服务器报告。这样，微信服务器便会得到诸如”某时某分，某某用户说巴拉巴拉“的记录。 5.结论所以，微信不对用户聊天记录进行存储，但是可以屏蔽用户发送敏感信息，也可以知道敏感信息的具体内容，从技术角度来说，是很正常也很合理的事情。在微信客户端中，也并没有云端存储的选项，换新手机之后聊天记录也必须从旧手机备份。 所以，我觉得，微信并没有说谎。但是微信可以做到“我知道也不关心你平时在说什么，但是你要是想说不该说的，我一定会知道。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「iOS」高仿【少数派】客户端 代码+思路讲解]]></title>
      <url>%2F2017%2F10%2F01%2F%E9%AB%98%E4%BB%BF%E5%B0%91%E6%95%B0%E6%B4%BE%2F</url>
      <content type="text"><![CDATA[一、写在前面在我的iOS开发学习过程中，阅读过许多同学的高仿项目文章、源码，对我助益颇深。但是许许多多的高仿项目在技术方面各有侧重，所以我先把本项目中值得探讨的技术点列出，方便正好需要的同学。 本项目重点探讨： UITableview的性能优化 UIScrollView的进阶使用 少数派客户端导航栏动态效果的实现 UITableview的多种控件嵌套 手动封装一些常用的视图控件 二、简述首先来看一下项目的运行效果：对于原客户端的一些重复性细节没有全部实现，欢迎大家fork。 这里是 LYSSPai项目地址。 在本文中，我会先介绍项目的整体实现思路，然后对于开发过程中遇到的值得探讨的点进一步讲述。 项目中的数据来源为使用Charles抓包获取，用json文件存在bundle中。项目中的素材来源为官方客户端ipa包使用iOS Images Extractors解析获得。声明：仅用于学习交流，严禁用于商业用途。 三、整体实现思路在这一节，我会按照页面来介绍整体开发思路。 1. 首页 1.1 页面简述 这是项目的首页，主要结构是顶部的导航栏和下面的内容。 导航栏效果：在页面向上滑动时，顶部导航栏的文字、按钮尺寸会随之动态减小，而后整体上移，悬停在顶部，模拟系统的导航栏效果。当页面下滑时，效果相反。 内容展示部分：首先有一个左右滑动的类似轮播图部分。用以展示重点推荐的专题、文章、广告等。接下来是一篇文章。然后又是一个手动滑动的类似轮播图。用来展示付费的栏目。剩余部分全为文章。1.2 实现思路1.2.1 内容展示使用UITableview，包含三种cell。轮播图为横向的UIScrollView，为其中的每一个子cell设置tag值，点击事件以delegate的方式交由首页VC实现。文章展示cell为普通的cell。右上角的菜单按钮点击事件以delegate的方式交由首页VC实现。1.2.2 导航栏实现导航栏的动态效果需要随着内容滑动而进行，而后悬停在顶部。其中涉及导航栏的高度变化以及悬停效果。我们很容易想到使用UITableView的tableHeader和sectionHeader，那么先来明确一下这两种视图的特性：tableHeader没有顶部悬停效果，但是可以方便地更改视图的高度：1234567891011CGRect newFrame = headerView.frame;newFrame.size.height = newFrame.size.height + webView.frame.size.height;headerView.frame = newFrame;//beginUpdates和endUpdates方法用来以动画形式更改高度[self.tableView beginUpdates];//要更改tableHeader，必须显式调用set方法[self.tableView setTableHeaderView:headerView];[self.tableView endUpdates]; 而sectionHeader是默认带有悬停效果的，但是我没有找到可以高效更新视图高度的方法，所以这种方法果断放弃。对于tableHeader的悬停效果，可以在页面滑到临界点时，将tableHeader加入到与tableview同一层级的view中，手动实现悬停效果，这也是许多UIScrollView的子View想要实现页面悬停效果的方式。但是有一点需要知道，UITableView是一个庞大的对象，对它频繁更新势必会影响性能。而动态更改tableHeader时，会不停地改变整个UITableView的布局。为了一个小小的动态效果实在不必如此。所以，我使用一个单独的view作为顶部的导航栏，并且将它和tableview加入到同一个容器scrollview中。这样动态效果仅仅影响这个单独的view布局。 1.2.3 分类专题页点击首页右上角的按钮或者在内容cell中左划，会进入分类专题页面。这个页面只是简单模拟实现了一下。 1.2.4 文章阅读页面点击文章cell或者轮播部分的文章类型子cell，会进入对应的文章阅读页面。这个页面底部导航栏为手动模拟实现。文章展示使用WKWebView。在整个页面包含web内容部分，均可以右划返回。 关于使用WebView展示内容的探讨，在我的简书文章从简书iOS客户端，来谈谈Hybrid方案细节设计进行了详细探讨，欢迎大家阅读。 2.发现这个页面和首页类似，并且比首页简单，略过不表。 3.消息这个页面没有特别复杂的部分。不过自己封装了选择器View，效果和原客户端完全一致，需要的同学可以阅读这部分代码。其中涉及到UIScrollView的一些进阶特性，一会会详述。 四、重点详述1. tableview性能优化 优化场景页面开发完成后，cell嵌套scrollview，其中还包括多个子cell，如果不加优化的话，可以预见使用体验不会太好。在第一次滑动到第二个轮播图时，很明显感受到页面fps下降。而后滑动流畅，fps基本保持在60。所以我们知道，优化重点在于轮播图的首次加载、渲染。轮播图首次出现在屏幕范围中之后，被加入缓存，所以再次滑到这里时便不会卡顿。说到性能优化，不得不推荐一下ibireme的文章，强烈建议没看过的同学认真阅读一下iOS 保持界面流畅的技巧。 优化思路滑动页面时fps在60左右时，用户不会感觉到卡顿，这是优化的目标。也就是说，我们需要在1s/60 = 16.7ms内，完成每一帧的渲染。而视图渲染需要CPU运算+GPU渲染运算共同完成。所以我们需要分析在这个场景下，CPU与GPU各自的工作量，合理调配，从而使它们的每一帧运算耗时总和低于16.7ms。 cell重用cell重用是非常基础但又非常重要的优化手段，正确使用tableview的cell重用机制。 cell高度缓存tableview的渲染过程中，有多少个cell，就会调用多少次- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath方法，从而确定contentSize。所以，尽量将cell的高度提前计算并且进行缓存，避免在这个代理方法中进行计算，可以有效优化tableview的渲染。 布局计算优化布局的计算是CPU的工作，当页面层级复杂时，布局计算就会耗费较多时间。同时，应该明确的一点是使用Masonry自动布局是将布局计算量交给CPU去完成，势必会相对增加耗时。所以，在复杂cell的优化中，一般建议手动计算布局，会稍微提升一些性能。除此之外，如果页面布局计算量比较大的话，将布局计算在页面渲染之前完成并且缓存，会有效减少视图渲染时的16.7ms中的CPU运算时间。在本项目中，我为轮播图cell封装了一个frameModel，在页面数据获取完成后，提前计算轮播图的布局结果，在页面渲染时，无需计算便可以直接赋值。1234567891011121314151617181920212223242526272829//count为轮播图子cell数量+(instancetype)PaidNewsFrameModelWithCount:(NSInteger)count&#123; PaidNewsFrameModel *model = [[self alloc] init]; float cellWidth = LYScreenWidth * 0.55; float cellHeight = LYScreenWidth * 0.7; model.cellTitleFrame = CGRectMake(25, 10, 100, 18); model.moreFrame = CGRectMake(LYScreenWidth - 65, 11, 40, 16); model.backScrollViewFrame = CGRectMake(0, 43, LYScreenWidth, cellHeight); model.paidNewsViewFrames = [[NSMutableArray alloc] init]; model.paidTitleFrames = [[NSMutableArray alloc] init]; model.avatorFrames = [[NSMutableArray alloc] init]; model.nicknameFrames = [[NSMutableArray alloc] init]; model.updateInfoFrames = [[NSMutableArray alloc] init]; for ( int i = 0; i &lt; count; i++) &#123; NSValue *paidNewsViewFrame = [NSValue valueWithCGRect:CGRectMake(25 + (cellWidth + 15) * i, 0, cellWidth, cellHeight)]; [model.paidNewsViewFrames addObject:paidNewsViewFrame]; NSValue *avatorFrame = [NSValue valueWithCGRect:CGRectMake(15, cellHeight - 90, 20, 20)]; [model.avatorFrames addObject:avatorFrame]; NSValue *nicknameFrame = [NSValue valueWithCGRect:CGRectMake(45, cellHeight - 85, cellWidth - 75, 12)]; [model.nicknameFrames addObject:nicknameFrame]; NSValue *updateInfoFrame = [NSValue valueWithCGRect:CGRectMake(15, cellHeight - 50, cellWidth - 30, 12)]; [model.updateInfoFrames addObject:updateInfoFrame]; &#125; return model;&#125; 可以看到，带有for循环并且每一个循环体都稍有计算量，将这些计算工作提前并且在子线程执行是非常明智的。我们要让那16.7ms“用在刀刃上”。 正确选择视图控件，为视图瘦身UIView和CALayer的关系大家应该都有所了解。UIView在CALayer的基础上，封装了交互操作相关的部分，UIView是比CALayer更重量的。如果当前控件不需要响应用户操作，我们应该尽可能使用CALayer替代UIView。在本项目中，付费内容轮播图部分，整个子cell需要响应用户的点击操作。所以只需要在子cell的最底层view添加手势识别。而背景图片、用户头像等元素是不需要响应特殊操作的，所以这些控件不使用UIImageView，改用CALayer。其实文字部分，也可以不使用UILabel，这是可以继续优化的部分。这是头像部分的布局代码： 12345678CALayer *avator = [[CALayer alloc] init];[paidNewsView.layer addSublayer:avator];NSValue *avatorFrame = self.model.paidNewsFrame.avatorFrames[i];avator.frame = avatorFrame.CGRectValue;[avator yy_setImageWithURL:[NSURL URLWithString:self.model.PaidNewsData[i][@&quot;avatar&quot;]] placeholder:nil options:kNilOptions progress:nil transform:^UIImage * _Nullable(UIImage * _Nonnull image, NSURL * _Nonnull url) &#123; image = [image yy_imageByRoundCornerRadius:40.0]; return image;&#125; completion:nil]; 网络内容异步加载待页面显示出来之后，网络内容再慢慢加载，也是为了将时间用在刀刃上。异步加载网络图片的框架，有大家都熟知的SDWebImage，也有ibireme的YYWebImage。据介绍YYWebImage的性能是要比SD好一些的，这个我没有亲自验证。这里我使用了YYWebImage： 1234[avator yy_setImageWithURL:[NSURL URLWithString:self.model.PaidNewsData[i][@&quot;avatar&quot;]] placeholder:nil options:kNilOptions progress:nil transform:^UIImage * _Nullable(UIImage * _Nonnull image, NSURL * _Nonnull url) &#123; image = [image yy_imageByRoundCornerRadius:40.0]; return image;&#125; completion:nil]; 圆角设置又是老生常谈的圆角设置。使用CALayer的相关属性来实现圆角效果会触发离屏渲染，增加GPU的工作量。在这一点的优化上，可以使用CPU将图片素材直接裁剪为圆角图片再进行显示。当然，最优的方案当然是让你们的美工直接提供圆角素材~这里我直接使用了YYImage的圆角处理。 2. UIScrollView的进阶使用这个部分我主要讲的是消息页面的选择器控件封装的思路。先看效果：一个非常简单的控件。但是有一个细节需要注意：使用轻划手势左右滑动时，页面必然进行滚动。而使用拖拽时，则会判断拖拽范围来决定是否进行滚动。这个效果我使用了UIScrollView的代理方法- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate来实现。这里是代码： 12345678910111213141516171819202122232425262728293031323334//停止拖拽时的代理- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123;// 如果是内容页的横向滑动 if (scrollView == self.contentView) &#123; NSLog(@&quot;slowing?? %@&quot;,decelerate ? @&quot;YES&quot; : @&quot;NO&quot;); CGFloat scrollX = scrollView.contentOffset.x;// 如果带有惯性（快速滑动），则内容页必然进行对应的移动 if (decelerate) &#123; if (self.selectedTag == 0 &amp;&amp; scrollView.contentOffset.x &gt; 0) &#123; self.selectedTag = 1; &#125; else if (self.selectedTag == 1 &amp;&amp; scrollView.contentOffset.x &lt; LYScreenWidth) &#123; self.selectedTag = 0; &#125; &#125;// 如果无惯性（慢速拖拽），此时需要满足拖动的范围才会进行移动 else &#123; if (self.selectedTag == 0 &amp;&amp; scrollX &gt;= 0.5 * LYScreenWidth) &#123; self.selectedTag = 1; &#125; else if (self.selectedTag == 1 &amp;&amp; scrollX &lt;= 0.5 * LYScreenWidth)&#123; self.selectedTag = 0; &#125; &#125; [self contentViewScrollAnimation]; &#125;&#125; 当轻划页面时，scrollview是有惯性的，而拖拽时是没有惯性的，利用这个特性来进行相应的判断。这里是小横条移动的动画：1234567891011121314//内容页进行移动的封装- (void)contentViewScrollAnimation&#123; //根据此时选中的按钮计算出contentView的偏移量 CGFloat offsetX = self.selectedTag * LYScreenWidth; CGPoint scrPoint = self.contentView.contentOffset; scrPoint.x = offsetX; //默认滚动速度有点慢 加速了下 [UIView animateWithDuration:0.3 animations:^&#123; [self.contentView setContentOffset:scrPoint]; &#125;];// 通知选择器，进行小横条的移动 [self.selectView selectBtnChangedTo:self.selectedTag];&#125; 3. 导航栏动态效果的实现先重新看一下效果：这里使用scrollview的代理方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView来实现。这是代码的部分：12345678910111213141516171819// scrollview刚刚开始滑动，此时导航标题大小和按钮大小进行变化 if (Y &lt;= -97 &amp;&amp; Y &gt; -130) &#123; // 以字号为36和20计算得出的临界Y值为-97和-130，根据此刻Y值计算此时的字号 CGFloat fontSize = (-((16.0 * Y)/33.0)) - 892.0/33.0; self.titleLabel.font = [UIFont fontWithName:@&quot;HelveticaNeue-Bold&quot; size:fontSize]; // NSLog(@&quot;point:: %f&quot;,self.titleLabel.font.pointSize); // 更新titlelabel的高度约束 [self.titleLabel mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.height.mas_equalTo(self.titleLabel.font.pointSize + 0.5); &#125;]; // 计算此刻button的对应尺寸，若大于最小值（16），则更新约束 CGFloat buttonSize = self.titleLabel.font.pointSize * (5.0/9.0); if (buttonSize &gt;= 16.0) [self.button mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.width.mas_equalTo(buttonSize); make.height.mas_equalTo(buttonSize); &#125;]; &#125; 这里计算比较繁琐，可以仔细看一下。 4. UITableview的多种控件嵌套这个部分内容在前文的页面实现部分已经简单讲过，这里列出来是提醒初学的朋友可以稍作留意。 5. 手动封装一些常用的视图控件在本项目中，我封装了页面的导航栏视图HeaderView，选择器视图SelectView以及页面的加载loading视图LYLoadingView。需要了解的同学可以留心看一些。这里简单展示一下loading视图的封装。这是头文件部分：123456@interface LYLoadingView : UIView//隐藏传入view中的loadingview+ (BOOL)hideLoadingViewFromView:(UIView *)view;//为传入view显示一个loadingview+ (BOOL)showLoadingViewToView:(UIView *)view WithFrame:(CGRect)frame;@end 这是实现部分：12345678910111213141516171819202122232425+ (BOOL)hideLoadingViewFromView:(UIView *)view&#123; NSEnumerator *subviewsEnum = [view.subviews reverseObjectEnumerator]; for (UIView *subview in subviewsEnum) &#123; if([subview isKindOfClass:self]) &#123; [subview removeFromSuperview]; return YES; &#125; &#125; return NO;&#125;+ (BOOL)showLoadingViewToView:(UIView *)view WithFrame:(CGRect)frame&#123; LYLoadingView *loadingView = [[LYLoadingView alloc] initWithFrame:frame]; loadingView.backgroundColor = [UIColor whiteColor]; UIActivityIndicatorView *indicator = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleGray]; indicator.center = CGPointMake(frame.size.width/2, frame.size.height/2 - 100); [indicator startAnimating]; [loadingView addSubview:indicator]; [view addSubview:loadingView]; return YES;&#125; loading视图模仿官方app的一个简单菊花指示器。使用时，在页面渲染最开始在视图上加一个loadingview：123// 初始化loadingviewCGRect loadingViewFrame = CGRectMake(0, 130, LYScreenWidth, LYScreenHeight - 130);[LYLoadingView showLoadingViewToView:self.view WithFrame:loadingViewFrame]; 页面数据获取完成后，table进行reload，然后移除loading视图：123[self.newsTableView reloadData];// 隐藏loadingview[LYLoadingView hideLoadingViewFromView:self.view]; 五、写在最后这个项目并没有100%完全复原官方客户端，笔者闲暇时间不允许，所以算是仓促结束，并且写了这篇文章作结尾。项目中还存在一些bug，也有未完成的功能点，欢迎大家fork。有不足之处欢迎大家指出，也欢迎讨论项目中的其他实现方式，希望帮助到需要的同学。 最后再贴一下 LYSSPai项目地址。如果觉得不错，希望点个star~ halo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从简书iOS客户端，来谈谈Hybrid方案细节设计]]></title>
      <url>%2F2017%2F08%2F06%2F%E4%BB%8E%E7%AE%80%E4%B9%A6iOS%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E6%9D%A5%E8%B0%88%E8%B0%88Hybrid%E6%96%B9%E6%A1%88%E7%BB%86%E8%8A%82%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[作为一位 iOS 开发人员，你应该已经敏感地发现，自己的工作涉及内容已经不止于 Native 的部分，因为 Hybrid App 和 ReactNative 等技术方案已经不仅仅是概念，越来越多的公司开始着手自己的 Hybrid 方案以及 ReactNative 本地化工作。 一、引言介绍相关概念的优秀文章已经有许多，方案的实现原理你也应该已经或多或少有了一些理解。不了解也没有关系，在这篇文章里，我将用简书 iOS 客户端的有关特性，来探索一下 Hybrid 方案的技术细节。文章的目的是抛砖引玉，用一个具体的项目，大家很熟悉的简书客户端，来帮助大家认识 Hybrid 方案，然后亲自实现它 。 从现在开始，不再着眼于某一个 feature ，你需要站在一个客户端架构师的角度来看待问题。 二、我们用到的简书客户端特性1.界面构成分析 本文的主角是简书 iOS 客户端的文章展示页面，这是我的一篇文章的展示页面： 如你所见，文章内容的展示是使用webview控件，具体是UIWebview还是WKWebview按下不表，这不是本文的关键。在我的demo中，我使用了UIWebview。 在简书发现tab栏的内容顶部，还有一个热门内容推荐的轮播图。与它类似是一些app内的活动推介轮播图，以及广告页面，它们的详情页内容展示多使用webview。在简书中，这个轮播图对应的下一级页面也是文章展示页面，特性基本一致。 在 webview 的基础上，添加了符合浏览器用户习惯的导航栏按钮。包括左侧的返回和关闭按钮。以及右侧的功能列表按钮。 页面底部，是一个工具栏，提供了四个常用的操作。注意这里的评论按钮，它是我们下文的一个谈论点。 2.界面特性分析 一般各家客户端的内容页，都会有一些适于自己功能点的设计。简书也不例外。比如，在文章内容区域点击作者的头像（它本身也是网页的一部分，暂且理解为对应一个链接），跳转到了作者的个人主页，注意，容易发现它是一个客户端的原生页面，也就是一个VC。 点击底部工具栏中的评论按钮（原生组件），页面（web页面）会滑动到评论区域，如图 对一篇文章写下自己的评论（使用了原生组件），评论列表（网页内容）进行更新。 简书对于展示内容作了内外站的区分。据我自己的简要测试，来自简书域名www.jianshu.com下的内容，在加载过程中，是没有进度条的，用户体验非常接近原生页面。而第三方的内容，则在加载过程中会出现一般浏览器中常见的加载进度条，如图： 对于简书域名下的内容，不会出现叉号的关闭按钮，这也是为了营造接近原生页面的用户体验，让用户不会察觉到这是一个 web 界面。而第三方内容，则会出现符合浏览器使用习惯的关闭按钮，如上图。 三、我们需要的储备知识1.Hybrid相关 在Hybrid架构中，原生界面和web页面需要频繁地沟通，并且是双向的沟通。原生代码可以构建JavaScript语句，交由webview进行执行，从而在web页面上实现需要的效果。而在web页面的js文件中，也可以调用原生的Objective-C方法，从而执行一些原生方法才能完成的操作。与此相关的库有WebViewJavascriptBridge以及JavaScriptCore，有需要的同学可以自行了解。 2.UIWebview的相关特性 UIWebviewDelegatewebview的代理方法大家想必非常熟悉，我们可以在页面加载前、开始加载时、加载完成时以及失败时进行需要的操作。这里我们需要用到的是这一条代理方法：- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;webview根据它的返回结果来决定是否进行加载。 执行JS语句的方法：- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;我们可以自行构建一条JS语句，通过这个方法交由webview执行 goback相关UIWebview拥有布尔类型的canGoBack、loading等属性，通过监测它们的值我们可以知道当前页面是否可以进行回退，以及页面是否正在加载。与之对应，拥有- (void)goBack;等方法，调用之页面会进行返回，就像我们在浏览器中常见的那样。 四、相关特性的模仿实现对于上文中提到的相关特性，我写了一个demo，对它们进行了简要的模仿实现。当然简书官方的实现会考虑到方方面面，而我的demo仅是从Hybrid架构的思想出发，盼能够抛砖引玉。这是demo中对该页面的模仿实现： 1.页面初始化在demo中，使用一条web页面的URL来初始化VC：- (instancetype)initWithURL:(NSURL *)URL;这条URL对应文章的链接。顶部导航栏和底部工具栏都是系统原生的UINavigationBar和UIToolBar，按钮素材使用阿里巴巴的iconfont字体。 2.点击作者头像进入个人主页关于这个特性的实现，如果按照 Hybrid 架构的思想，属于 Web 页面调用原生方法，进入一个原生的VC。点击头像，JS脚本执行相关代码，调用原生方法暴露出来的接口，执行原生方法。我在这里用一种简要的方法实现：原生代码利用之前提到的代理方法，在用户点击头像后，拦截该URL，分析URL为头像部分，直接执行原生方法跳转到个人主页VC。通过分析简书文章页面的网页源代码，我发现用户头像对应的URL中的Query部分，有一个参数为utm_medium=note-author-link。据此，在- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType代理方法中加以判断，若是头像链接，则跳转到个人主页VC。下面是相关代码：12345678910NSURL *destinationURL = request.URL;NSString *URLQuery = destinationURL.query;// 简书点击文章中头像时跳转至原生页面。此处利用头像链接中的一个参数作判断if ([URLQuery containsString:@&quot;utm_medium=note-author-link&quot;])&#123;NSLog(@&quot;我跳转到个人主页啦&quot;);AvatorViewController *avatorVC = [[AvatorViewController alloc] init];[self.navigationController pushViewController:avatorVC animated:YES];return NO;&#125; 最后返回NO是因为若是头像链接，该web页面是不需要做跳转操作的。 这里顺便讲一个小tips：如果想要在Mac端查看移动端的网页源代码，那么你只需要在Safari中输入该页面，并且在开发选项下的用户代理中，选择iOS系统下的Safari作为代理，这时再使用源代码查看，看到的就是移动端的网页源代码了。 3.点击评论按钮，页面滑动到评论区域这个特性的实现方式和上面类似，点击评论按钮，原生代码构建一条JS语句，交由- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;方法进行执行，由web页面执行滑动操作。代码如下：1234- (void)scrollToCommentField&#123;[self stringByEvaluatingJavaScriptFromString:@&quot;scrollTo(0,20500)&quot;];&#125; 这里的JS语句非常简单，由于笔者的前端知识还有所欠缺，没有想到可以精确滑动到评论区域的JS语句，所以简要实现，点到为止。 4.原生组件写评论，web页面更新这里首先需要贴一下文章页面的网页源代码：123456&lt;!-- 评论列表 --&gt;&lt;div data-vcomp=&quot;comments-list&quot; data-lazy=&quot;3&quot;&gt;&lt;script type=&quot;application/json&quot;&gt;&#123;&quot;likedNote&quot;:true,&quot;commentable&quot;:true,&quot;publicCommentsCount&quot;:3,&quot;noteId&quot;:2491941,&quot;likesCount&quot;:43&#125;&lt;/script&gt;&lt;/div&gt; 可以看到，页面的评论内容是异步加载的。所以这个功能的实现，我认为比较合理的逻辑是原生组件向服务器提交一条新的评论，收到成功回调之后，原生组件和web页面进行交互，执行更新并加载评论列表的JS代码，从而看到自己发的新评论。 5.内外站页面的区分这里和点击头像的实现方法类似，通过拦截链接的URL，区分内部链接和第三方链接，从而在开始加载的时候采用不同的加载界面，或者对于第三方链接单独开启一个第三方VC。demo中关于第三方链接的关闭按钮的显示逻辑，做出了相应的处理。 五、demo中的不足看到这里大家应该就会发现，对于提到Hybrid我们就会想到的Bridge、Router等模块，我并没有做明显的限定。这样也是为了方便大家用一种更接近以往原生代码编写的思维，来理解Hybrid模式。同时，demo中较多涉及了原生代码对web页面做出的沟通操作。而没有JS代码对原生代码的调用，这是因为一来站在一个简书客户端的用户和iOS开发的角度，对于JS端执行的操作，有些力不能及，这本是和你共同工作的前端伙伴的任务，二来对于一篇帮助大家入门Hybrid的文章来说，从这个单方面的交互来入手，管中窥豹，已是足够。 六、一些感悟其实，写了这么多，我觉得收获到一些感悟是最重要的，下面的要讲的，可能是我觉得更为重要的思想性的东西。 1.未来的趋势之一，便是大前端团队进行客户端开发。 看到这里你发现，如果你们的团队想要采用Hybrid模式进行产品的开发，光靠iOS或者是安卓的客户端工程师是不可能完成的。在客户端框架的开发过程中，需要和前端的工程师沟通具体的技术细节。比如怎样设计接口能够更好地兼顾客户端和前端特点，对于某个问题，如何能把握全局而不是单单从客户端的角度来看待。这些可能是普通的iOS开发工程师和大牛的差距所在之一。 越来越多的客户端工程师招聘要求中，出现了熟悉前端语言的要求。如果你能在精通客户端开发之余，对前端语言也游刃有余，那么在接下来的发展趋势中，就会有更多的可能性。所以，请开始你的前端学习吧~。 2.在Hybrid模式下，如何进行产品技术方案的取舍 如前文所见，简书客户端对于内部域名的内容和第三方内容，在展示方式上是有明显不同的。在阅读简书的文章时，让用户发现不了自己是在一个浏览器上进行阅读，这在方方面面就极大改善了用户体验。为了做到这一点，我推测简书首先需要对自己的内容进行非常良好的CDN加速，以保证内容加载时不会耗时过长，同时采取一些预加载策略，二是在内容加载时，采用与原生界面部分相同的loading界面，去掉进度条，模拟原生界面的加载过程。而对于第三方的链接，采用进度条+返回、关闭按钮的设计，则更符合用户在浏览器中进行阅读的习惯，也可以和自己的内容进行直观区分，这也改善了用户体验。 对于某些原生和Web页面都可以实现的特性如何取舍，这也是需要考虑的问题。比如，点击评论按钮页面滑动，这个功能使用web页面的滑动而非原生的控制显然更为自然也更符合用户习惯。而对于撰写评论的功能，使用原生的键盘、编辑器组件，当然就比使用web页面的键入更加稳定可控了。 七、文章的demo对于文章内容，我写了一个demo，这是demo地址。为了便于理解，我为代码写了详尽的注释。如果觉得它对你有帮助，不妨在github上为我点一个star~非常感谢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「LYIconfont」快捷设置iconfont的工具类]]></title>
      <url>%2F2017%2F08%2F04%2F%E3%80%8CLYIconfont%E3%80%8D%E5%BF%AB%E6%8D%B7%E8%AE%BE%E7%BD%AEiconfont%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[在刚刚接触iOS开发的时候，每次涉及到图标、按钮等绘制工作时，都觉得无比繁琐。因为我们需要将尺寸合适的图片格式的素材加入到项目中，设置一系列冗杂的UIImageView相关设置。当然，如果需要在不同分辨率下显示，我们还需为一个图标准备多个不同分辨率的素材。当你的设计改变，仅仅想要将一个小图标的颜色进行替换时，就不得不重新制作图片素材，并在项目中进行替换。 你看到了，加粗的关键词都是我对这种开发模式的吐槽。 在之前的文章里，我就已经向大家强烈安利过iconfont，今天终于可以为它单独写一篇文章。 iconfont简介到如今，我们拥有了iconfont技术，在前端、客户端等领域都被广泛使用。简单来说，就是它将图标素材转换为矢量的字体文件的形式在界面中进行展示。 如你所见，它是矢量素材，我们不需要为了不同分辨率下分别进行设置，像你的UILabel中的文字一样，它是一直高清的。 同时，它是一种字体，所以当你想要更换颜色时，只需要像更换UILabel颜色一样，对它的颜色进行代码设置。 当然，更重要的是，你不再需要图片格式的素材，客户端的体积和性能表现也会有相应提升。 在这里，向大家强烈推荐阿里巴巴的iconfont图标库。 LYIconfont介绍当然，在iconfont的使用过程中，我也遇到了一些令人懊恼的问题。比如，要想使用一个iconfont形式的图标，我需要编写一大堆繁琐的代码，如你所见： 12345UIButton *reLocate = [[UIButton alloc] initWithFrame:CGRectMake(DEAppWidth - 90, 15, 80, 15)];[reLocate setTitle:@&quot;\U0000e8a4 重新定位&quot; forState:UIControlStateNormal];[reLocate setTitleColor:DEColor(26, 152, 252) forState:UIControlStateNormal];reLocate.titleLabel.font = [UIFont fontWithName:@&quot;iconfont&quot; size:15.0];reLocate.contentHorizontalAlignment = NSTextAlignmentRight; 这是对一个UIButton形式的iconfont图标进行设置所需的代码量。 所以我对诸如此类的设置代码进行了封装，方便iconfont形式素材的使用。 这里是项目地址。如果它对你有帮助，希望点一个star~ 使用方式 项目中引入LYIconfont.h和LYIconfont.m文件 在需要设置iconfont图标的文件中引入LYIconfont.h头文件 调用方式： 获取一个UIButton类型的图标： 1UIButton *iconfontBtn = [LYIconfont LYIconfontButtonWithFrame:frame code:@&quot;\U0000e6e9&quot; color:someColor size:25.0]; 获取一个UILabel类型的图标： 1UILabel *iconfontLabel = [LYIconfont LYIconfontLabelWithFrame:frame code:@&quot;\U0000e6e9&quot; color:someColor size:25.0]; 参数解析： frame 你的按钮或标签形式的图标frame code 你的图标素材编码 color 你的图标颜色 size 你的图标尺寸]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「PHP」行车服务app后端代码简析]]></title>
      <url>%2F2017%2F05%2F24%2F%E3%80%8CPHP%E3%80%8D%E8%A1%8C%E8%BD%A6%E6%9C%8D%E5%8A%A1app%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%AE%80%E6%9E%90%2F</url>
      <content type="text"><![CDATA[之前发布了一篇关于我的行车服务appiOS端代码简析的文章：文章地址。 此篇是对这个项目后端PHP代码的简析。 iOS端代码地址： iOS代码，PHP代码。如果你觉得有帮助，希望能够点个Star，感谢~ 笔者对于PHP学习也刚开始不久，所以此篇不敢妄言指导，只是把这个项目后端代码的结构、实现讲述一遍，希望大家多多指教。适合想要自己尝试使用PHP搭建一个API项目的同学阅读。 项目结构 封装好的公共文件 heloper/ 这个部分包括MySQL交互、JSON包装函数、`返回结果函数。 各个接口实现文件 interface/ 这个部分是各个接口的实现文件，由路由文件按需调用。 入口文件，接口路由 receiver.php 这个部分是整个项目的路由文件，接收请求，然后分发给各个接口实现文件。 代码实现 公共文件 heloper/： common.php：这个文件封装了两个包装返回结果的函数。 returnData ($msg, $code, $data)：适用于获取数据类型的接口，它带有data参数。返回结果示例： 123456789101112131415161718192021&#123; &quot;msg&quot;: &quot;ok&quot;, &quot;code&quot;: &quot;1&quot;, &quot;data&quot;: &#123; &quot;count&quot;: &quot;3&quot;, &quot;points_list&quot;: [&#123; &quot;id&quot;: &quot;19&quot;, &quot;poi_name&quot;: &quot;sss&quot;, &quot;poi_address&quot;: &quot;sss&quot;, &quot;uid&quot;: &quot;fuck&quot;, &quot;points&quot;: &quot;30&quot; &#125;, &#123; &quot;id&quot;: &quot;25&quot;, &quot;poi_name&quot;: &quot;洗车装饰服务&quot;, &quot;poi_address&quot;: &quot;北三环西路76号附近&quot;, &quot;uid&quot;: &quot;B0FFHF5BKD&quot;, &quot;points&quot;: &quot;30&quot; &#125;] &#125;&#125; returnMsg ($msg, $code)：适用于仅返回状态的接口。返回结果示例： 1234&#123; &quot;msg&quot;: &quot;添加成功&quot;, &quot;code&quot;: &quot;1&quot;&#125; jsonHelper.php： arrayRecursive(&amp;$array, $function, $apply_to_keys_also = false)函数作用是对数组中的元素递归地进行传入的$function操作。 JSON($array)函数用于将数组包装为JSON格式。 sqlHelper.php：这个文件中对所使用数据库名称、账户信息等进行设置，大家可以按照自己的信息自行在此配置。 路由文件receiver.php： 这个文件是整个项目的调用入口，具体接口调用时的url示例即为：服务器IP地址/DriverEpoch-Server/receiver.php。 本文件解析参数中的if参数，然后分发到对应的接口文件。 例如，if=Login，即为调用登录接口，分发到登录接口的实现文件：1case &quot;Login&quot;: require &quot;interface/Login.php&quot;; break; 各个接口实现文件interface/：这部分我对于两个类型各选取一个接口来讲述一下。 返回状态类型：AddPlace： 这个接口用来为用户添加历史足迹。 参数列表： user_id: 用户id latitude:纬度 longitude:经度 place_name:地点名称 place_address:地点地址 很简单，解析到POST方式传入的各个参数之后，构建一条mysql语句，作用是向对应的表插入一条数据： 1$sql = &quot;INSERT INTO historyPlaces (user_id, latitude, longitude, place_name, place_address) VALUES (&apos;$user_id&apos;, &apos;$latitude&apos;, &apos;$longitude&apos;, &apos;$place_name&apos;, &apos;$place_address&apos;)&quot;; 执行之后，若mysql表示执行成功，则返回JSON格式的成功信息。否则返回失败信息，此处就要使用前文提到的封装好的工具函数。 返回状态+数据类型：GetPlaces： 这个接口用于获取用户的所有历史足迹。 参数列表： user_id:用户id 这种类型的接口比刚刚的稍微复杂一些。拿到参数后，构建一条查询语句，查询用户的所有历史遗迹： 1$sql = &quot;SELECT add_time,place_name,place_address FROM historyPlaces WHERE user_id = &apos;$user_id&apos; ORDER BY add_time&quot;; 取到结果后，若结果条数为0，则返回结果条数为0的信息。否则，将mysql返回结果的每一行都包装成为数组的一个元素，然后将数组包装为JSON，返回给客户端。 123456789101112131415$places_list = null;$i = 0;$num = mysqli_num_rows($sqlResult);while($row = mysqli_fetch_array($sqlResult)) &#123; $places_list[$i][&apos;add_time&apos;] = $row[&apos;add_time&apos;]; $places_list[$i][&apos;place_name&apos;] = $row[&apos;place_name&apos;]; $places_list[$i][&apos;place_address&apos;] = $row[&apos;place_address&apos;]; $i++; if ($i &gt;= $num)&#123; break; &#125; &#125; $data[&apos;count&apos;] = $i; $data[&apos;places_list&apos;] = $places_list; returnData(&quot;ok&quot;, 1, $data); 其他接口的实现文件大同小异，有一些具体的点大家可以和我继续交流。 写在最后： PHP的语法非常简单，我个人觉得不太需要刻意去看语法，有其他语言基础的同学看几份代码就可以上手写，勇于尝试，加油！ 我后续会再写一篇关于自己部署LAMP架构的PHP项目的教程，希望能和前文形成一个自己DIY全端项目的教程。 项目已开源，如果觉得有用，希望点一下star~感谢~halo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「iOS」行车服务app 「客户端、后端思路+代码」]]></title>
      <url>%2F2017%2F05%2F24%2FEpoch%E4%BB%A3%E7%A0%81%2B%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[最近开发了一个行车服务项目，iOS客户端采用Objective-C编写， 后端采用PHP搭建，部署在阿里云，操作系统为Linux CentOS 7.3，数据库MySQL，服务器为Apache，是比较基础的LAMP组合。 iOS端代码部分我会讲述整体的开发思路，一些有意思的功能点也会详细说说。 后端代码比较简单，想要自己尝试开发API的iOS开发者可以参考。 发这篇文的主要目的是对最近的开发做一个整体回顾，同时希望对有需要的同学提供到一些帮助，有很多不尽合理和完善的地方，也请求各位同学不吝赐教，感谢大家！ 首先上整体的效果图： 在POI检索结果页面，地图控件显示为空白，是因为模拟器运行的原因，真机效果良好 这里是 iOS项目地址、后端项目地址 。如果有帮助，希望点一下Star以示鼓励，感谢~「Tips」：对于发现代码运行报错的同学，项目使用CocoaPods进行第三方库的集成。之前为了方便我对Pods文件夹做了ignore操作。刚刚已经更新，大家可以直接打开后缀为xcworkspace的项目文件运行。不过这样Github上面的项目体积会比较大。 简单介绍：项目UI整体尽量保持了饿了么的蓝色风格，其中某些页面参考了高德地图、饿了么、Max+的设计风格。 项目功能点 账户、用户资料管理 参照饿了么UI的定位、天气模块 基于高德地图API开发的POI检索，同时界面也加入了一些和高德地图app类似的特性 自定义交互逻辑的预定及结果通知功能 简单参照Max+app的资讯模块 用户历史足迹、历史事件维护 项目使用到的API及第三方库 高德地图API 和风天气API 自己搭建的后端相关接口 AFNetworking 3.0 SDWebImage MBProgressHUD 项目内的Icon大量使用阿里巴巴的iconfont图标，极力推荐 项目涉及的技术点 高德地图API的相关使用。包括地图、POI检索、导航等功能。 GCD的使用示例。包括耗时操作的后台执行、UI更新相关操作等。 NSUserDefaults维护账户信息。这里是为使用方便，仅供参考。 Core Animation的使用。由于TableView加载时采用HUD的用户体验不是很友善，我自己封装了Loading页面。 开发思路 登录注册页面 项目初始化时采用Tabbar VC作为rootController，如果此时没有账户信息，则采用模态弹出方式弹出登录页面。 这部分比较简单，客户端会先对用户输入的信息进行简单的合法判断，然后调用登录接口。 有一些关于TextField的点击空白和Return回收键盘以及呼出键盘时控件移位防止遮挡的代码可以注意一下。 在Tabbar VC初始化时，第一个tab栏的VC会进行定位操作，如果此时为已登录状态，则直接调用发送历史足迹的接口。在未登录状态下，用户点击登录按钮，登录成功时，会向第一个tab栏VC发送一个调用历史足迹接口的通知。 主界面（tabbar栏首页） 地理位置和天气部分。 这部分是单独封装的View，UI参考了饿了么。地理位置和通知列表按钮的点击事件采用代理交由当前VC实现。 由于模拟器定位获取的坐标无法使用高德地图的国内API，我对运行环境做了一下判断，如果是模拟器运行，则设置了默认坐标，对应地点大概是北京市海淀区北京理工大学。 当前VC加载过程中，开启定位，在地理位置反编码的成功回调中调用天气信息的接口。注意地理位置和天气信息的UI更新放在主线程执行。 点击地理位置的文字时，会模态弹出重新定位的界面，重新定位按钮的点击事件使用代理交由主界面VC实现，避免在此界面再次实例化定位相关的对象。 功能栏 使用UICollectionView展示。各个Cell的Icon使用阿里巴巴的iconfont图标，将以往的图片素材转为字体来使用，对于素材整理、高清保真、代码方便来说有极大的效率提升。在Web、移动客户端开发领域已经非常广泛地在使用。 某一功能VC 这部分UI参考了高德地图的附近界面UI以及部分特性。导航栏隐去，最上面是一个地图控件，以及透明的返回按钮。下面是POI信息的tableview。在tableview向下滑动时，地图隐去，tableview的frame上移，导航栏出现。向上滑动到顶部时，tableview下移，地图出现，导航栏隐去。 tableview滑动时特性的实现：通过scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate代理方法，判断滑动的方向，从而对tableview的frame以及导航栏等元素进行操作。 代码如下： 1234567891011121314151617181920212223242526272829//判断滑动手势方向，决定tableview的frame改变-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123;CGPoint translation = [scrollView.panGestureRecognizer translationInView:scrollView.superview];if (translation.y&gt;0) &#123; NSLog(@&quot;ssssss&quot;); &#123; NSIndexPath *dic = self.poiList.indexPathsForVisibleRows.firstObject; if (self.poiList.frame.origin.y == 64 &amp;&amp; dic.row == 0)&#123; [UIView animateWithDuration:0.2 animations:^&#123; NSLog(@&quot;visible:::%@&quot;,dic); showMap = YES; self.navigationController.navigationBar.hidden = YES; self.poiList.frame = listFrame; &#125;]; &#125; &#125;&#125;else if(translation.y&lt;0)&#123; NSLog(@&quot;tttt&quot;); if (self.poiList.frame.origin.y == 300)&#123; [UIView animateWithDuration:0.2 animations:^&#123; showMap = NO; self.navigationController.navigationBar.hidden = NO; self.poiList.frame = listFullFrame; &#125;]; &#125;&#125;&#125; 在界面加载时，使用了自己封装的loading页面： 在页面view加载的最开始，将loading页的view加入到当前VC的view中。在页面数据加载完成的回调中，调用tableview的reload方法，而后将loading页移除。 loading页使用basicAnimation制作了简单的呼吸动画，keyPath为logo图标的透明度。 第一个cell的POI地点默认可预约，显示预约图标，点击进入预约界面。 这个部分的和后端的交互逻辑是自己定义的。一般的预约过程是预约请求发送成功后，一段时间内由店家进行同意或拒绝操作，而后客户端收到结果回执。由于本项目简单模拟此过程，均使用http协议进行通信。所以我的实现方式是后端收到预约请求后，直接采用随机数方式模拟店家的接受或拒绝。一定时间后，客户端调用结果查询的接口来获取预约结果。 实现方式为，点击预约按钮，若预约接口调用成功，按钮字样变为预约中，钟表icon开始转动，并且按钮变为不可点击状态。与此同时，使用performSelector方式延时调用获取预约结果的接口。在此网络请求的成功回调中，向主界面发送通知，而后主界面通知按钮右侧显示通知数量的红色图标。如图。 这里通知列表的数据是存在UserDefaults中的，不同设备之间无法同步。其中涉及到一些userDefaults中数据要求的知识，具体可以参考代码。这里是因为需求是临时想出，如果常规实现方式需要开发获取通知数据的接口。我为了节省开发时间所以采用这种方式来模拟实现了。这个地方在以后可以完善~ 资讯Tab栏 这里没有花费过多的精力。数据预置了网易新闻相关数据。界面UI参考了我常常使用的Max+iOS客户端的资讯功能。第一个Cell以全图为背景，可以用来突出显示重点内容。 资讯详情页是一个简单的webView。同样使用了自己封装的Loading图。移除时机就简单放在了webView的finishLoad回调方法中。其实对于Webview真正加载完成时机的判断还有很多可以聊的东西，日后补充。 设置页面 这个页面显而易见是采用两个section的tableview实现。在页面的viewWillAppear方法中，需要调用获取缓存数据大小的方法，单独更新清除缓存cell的内容。因为在每次切换tab的过程中，缓存数据都有可能发生变化。 个人信息 页面依然采用tableview实现。在信息编辑页面，仿照了微信信息更改页面的逻辑。页面出现时，立即弹出键盘。关于使textField在页面加载完成时即成为第一响应者的问题，需要重写- (BOOL)becomeFirstResponder方法。代码如下： 123456- (BOOL)becomeFirstResponder&#123;[super becomeFirstResponder];return [self.textInput becomeFirstResponder];&#125;​ 历史足迹、历史预定、积分信息 这部分也依然使用了封装的loading页面。如果数据条目为空，则不显示tableview，提示暂无相关信息，如图。 清除缓存 这里其实只使用了SDImageCache的相关方法。我们还可以清除本app的缓存数据所在目录来达到真正清除缓存的目的，日后讨论。 缓存数据获取的初始单位是B，我们需要除以10241次、2次来判断当前数据是在KB级别还是MB级别，并作正确显示。 退出登录 点击此按钮，清除userDefaults中相关数据，然后模态弹出登录页面。 这里可以注意的一点是，我们在模态弹出登陆页，并且再次登录之后，界面是在退出登录之前的页面的，也就是tab栏的第三个页面。如果想要再次登录之后，界面出现在tab栏的首页，我们可以在模态弹出登录页的完成回调中，对当前tabVC的selected index进行设置。代码如下：1234567891011DELoginViewController *loginVC = [[DELoginViewController alloc] init]; [self presentViewController:loginVC animated:YES completion:^&#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新界面 AppDelegate * appDelegate = (AppDelegate*)[UIApplication sharedApplication].delegate; appDelegate.tabbarVC.selectedIndex = 0; &#125;); &#125;); &#125;]; 代码的主要开发思路基本讲述完，具体的细节大家可以和我继续交流~项目中有许多不尽合理的实现方式，小部分是考虑到时间因素。欢迎大家进行讨论、指教。有相关的问题，欢迎大家进行留言。项目中使用的自有接口，部署在我的阿里云服务器中，可外网访问。请求大家合理使用。 后端项目相关的sql代码，如有需要我可以后续贴出。 如果大家有兴趣，以后我可以再讲述一下server端的代码，当然，后端我也是初学者的水平，仅供想要入门的同学参考。 我的个人博客网站地址： Halo的个人博客 ，欢迎大家访问。 代码已开源，地址在文章首部。如果点一下star，我真的会非常感谢~halo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动应用程序开发：Web VS. 原生(译)]]></title>
      <url>%2F2017%2F05%2F14%2FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E6%AF%94%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9B%B4%E4%BE%BF%E5%AE%9C%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E4%BB%AC%E8%83%BD%E5%A4%9F%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%94%9F%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E5%90%97%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[原文《mobile application Development: Web vs. native》,是由Andre Charland和Brian Leroux发布在《Communications of the Acm》的文章，深入探讨了移动领域Web开发和原生开发相关的问题。截止翻译，引用量320。 1Web应用程序的开发和部署比原生应用程序更便宜，但是它们能够匹配原生用户体验吗？ 移动应用程序开发：Web VS. 原生 短短几年前，大多数的移动设备，想要使用一个更贴切的词语来形容，是“哑的”。当然，也有一些早期的智能手机，但是他们要么是邮件集中，要么就是缺乏一个可以不用小尖笔就可以使用的先进触摸屏。附带一个有能力显示任何东西，不止是简单的文本，链接，或者是一个图像的像样的手机浏览器的就更少了.这意味着如果你有这些设备之一，你要么是一个沉迷于电子邮件的商人，要么是一个希望这是智能手机之年的最初的极客。之后苹果用iPhone的发布改变了一切，同时我们对于移动设备使用体验的预期被完全重设。 最初对于第三方iPhone应用程序的计划是使用开放的Web技术。苹果甚至为它的Dashcode项目发布了工具。快速向前发展的三年，原生应用程序大大流行。通常，就工作性能的原因来看，相比较来说移动Web正在变得不是最适宜的。 顺着这一条思考的路线有两个问题。首先，如果使用各自的原生语言来为不同平台构建应用程序是非常昂贵的。一个独立游戏开发者或者启动很有可能只可以支持一种设备，就像iPhone，但是一个IT部门必须支持它的用户的所有设备，即使它们不总是最新的和最好的。第二，原生应用程序适用于3D游戏或者图像处理时更快速的性能表现相关的争论，而且在一个使用Web技术良好构建的商业应用中有微小的、不引人注意的性能损失。 就其本身而言，谷歌正在为使用Web技术去解决平台分裂化问题押注。谷歌负责工程的副总裁，声称 “连谷歌也没有足够的钱去支持所有的不同的移动平台—从苹果的应用程序商店到黑莓、Windows移动操作系统、安卓，以及诺基亚平台的许多变种”。并且这是在惠普Web操作系统、MeeGo和其他平台问世之前。 在本文中，我们讨论Web和原生方法的一些优势和缺点，伴随着对于Web技术和它对应的原生同作用事务之间沟壑正在缩小的领域的特别关注。 原生代码 VS. Web代码 实现一个软件应用程序从代码开始。在原生代码的情况下，大多数时候开发者通常用C语言系列，就像在开发iPhone应用程序的情况下。在我们在Nitobi和PhoneGap上的工作中，我们已经有足够的经验从一个原生开发者的角度去应对多样变化的移动平台。 当然，由于多样变化的市场，或者是由于组织化的原因，大多数的开发者或者团队必须支持多个智能手机平台的应用程序。想要用原生代码写一个应用程序然后面对每一个单独的移动操作系统？没有问题，如果你的团队具有附带表格所展示的技能集。 使事情变得更复杂的是实际的平台开发工具集之间的不同。有不同的工具、构建系统、应用程序编程接口，以及对于每个平台有不同能力的设备。事实上，这些操作系统共同拥有的唯一事物是它们都附带一个可以编程化访问原生代码的移动浏览器。 每个平台都允许我们实例化一个浏览器实例，更简洁，并且可以使用它的JavaScript接口与原生代码相互配合。从Webview中我们可以通过JavaScript调用原生代码。这种攻击作为PhoneGap技术开始成名，由Eric Oesterle，Rob Ellis和Brock开创，于2008年在iPhone开发营为iPhone操作系统下开发工具集而写。这种方法后来被移植到安卓、黑莓，以及其他支持PhoneGap的平台。PhoneGap是一个开源的框架，它提供给开发者一个他们可以使用HTML、CSS和JavaScript来开发移动应用程序的环境，并且仍然可以通过通用的JavaScript接口调用原生的设备特性和传感器。PhoneGap框架包含原生代码片段，用来和底层操作系统互相配合以及传递信息给运行在Webview容器中的JavaScript应用程序。如今，有对地理定位、加速度计的支持，以及其他的许多。 那么原生代码到底是什么？它通常是编译型语言，比解释型语言例如JavaScript运行得更快。Webview浏览器使用HTML和CSS构建用户界面，具有不同程度的能力和成功。使用原生代码，我们可以通过专有的应用程序编程接口直接在屏幕上绘制像素，还可以抽象化通用的用户界面元素和控件。 简而言之，我们在让JavaScript和编译型语言较量。如今，JavaScript持有它自己。这并不令人惊异——JavaScript虚拟机技术是如今新的浏览器战争的前线。微软、谷歌、苹果、Opera和Mozilla都在激烈地反复迭代，竞争着完成实现。现在，通过一些基准，Mozilla的”蜘蛛-猴子“正在接近谷歌的V8引擎。苹果的JavaScriptCore，在大多数的WebKit浏览器（使用于数量最多的移动设备上）中建立，并介于其中。底线是所有主要参与者的沉重开支正在为这场JavaScript军备竞赛添火加柴。Ars Technica的基准图1是这些企业是如何推销自己的一个例子。 JavaScript正在迅速地变得更快——如此得快，事实上，惠普的Palm Web操作系统2.0版本重写了它的服务层，原来是Java，现在是极其受欢迎的node.js平台，它是构建于谷歌的V8引擎上并且在更低的CPU消耗下有更好的性能表现（因此具有更长的电池使用时间）。我们所能见到的趋势是Web技术栈运行在低水平，并且相应地在今天数以百万计的设备上。 用户界面代码 当谈到用户界面时，事情并不那么美好。大多数原生平台有通用用户界面控件和体验的极好的抽象。没有两个平台有一样的，甚至相似的用户界面模式，更不用说单独使用应用程序编程接口去实例化和访问它们。Web平台在大多数情况下是一致的，但是内建的或者开发工具集包含的控件的数量是有限的。你必须去自己开始工作。有时浏览器之间的不同会造成烦恼，但是至少在现代智能手机的世界中，大多数设备运行着最能干WebKit渲染引擎，而且它们之间只有微小的差异。 不幸的是，对于Web来说，那些微小的差异正在变成大问题。举个例子，在iOS中，CSS位置属性不能正确地支持一个“xed”的值。（这曾是安卓中的一个问题，但是已经在最新的安卓2.2代码中被修正。）黑莓操作系统在6.0版本之前运行着一个完全神秘的浏览器，对于Web开发人员的心智健康造成很多辛劳，也遭受很多痛苦。幸运的是，RIM在6.0版本中已经解决了很多类似的事情，并且一般来说，事情会变得越来越好。 一些操作系统包含一些叫做硬件加速的事物。iOS堆栈非常著名地支持了这个CSS转换的概念，这是关于Web框架如何顺畅地在视图状态之间转换。这是一个首先在Dashcode中被发明的技术。它由David Kaneda煞费苦心地反向工程化，在jQTouch上开创，并且后来在Sencha Touch发布。它们都是令人难以置信的Web项目，同时也是当开发人员推动边界时什么事情可以被完成的例子。 当我们首先开始利用这些下一代的移动浏览器时，没有什么框架可以在不同设备之间正确地工作。如今有超过20种的移动框架，并且相关支持正在被快速地添加到已有的文档对象模型库中——不止是John Resig的jQuery，还有jQuery移动版；那些代码正在被不断地完善，并且每天都在为更多的设备添加支持。有了这些类似的工具，从一个单独的面向Web的代码库去支持多个目标变得越来越容易。 当把Web技术栈和原生代码比较时，快速执行和漂亮的用户界面并不是故事的全部。Web技术存在于沙盒，这也是原生代码可以访问的低级API的笼子——可以访问设备存储、传感器和数据的API。但是这一沟壑也正在被弥合。如今大多数移动浏览器支持地理定位，举个例子，iOS最近增加了加速度计和一些其他的HTML5应用程序编程接口。考虑到W3C有一个设备API工作组，就好像我们在不久的将来将会看到许多连至浏览器的API。如果这个很近的将来不是足够短的话，现在你可以使用PhoneGap来获取这些API。 当然，Web技术堆栈(HTML/CSS/JS)本身就是用原生代码实现的。原生层和浏览器之间的距离就只是一个编译而已。换句话说，如果你想给一个浏览器添加一个原生的能力，你也可以桥接它或者重新编译这个浏览器以获得那个能力。如果一个浏览器不支持一个原生的能力，不是因为它确实不能，也不是因为它不愿意；它只是意味着它尚未完成。 用户体验：上下文环境与实现 另一个对原生和Web移动应用程序开发都有重大影响的领域是用户体验，我们使用这个术语来描述用户使用一个软件应用程序期间的全面的体验。用户体验甚至可以扩展到应用程序之外。举个例子，我们在某些情况下发送通知去唤醒一个应用程序，比如一个地理位置的变化，或者产生一个专用的应用程序去处理不同的应用方面。显然，一个成功的用户体验是采用成功应用的关键。 一般来说，一个移动软件项目的用户体验可以分为两个主要类别： 环境 元素必须能够被理解，但是不能被改变或者被控制。这些包括硬件功能，平台能力和用户界面规范，以及应用程序被使用的环境。 实现 在一个应用程序中可以被控制的元素，比如性能，设计以及集成平台特性，例如加速度计的数据或者通知。 你的应用程序将被使用的环境影响着用户的预期。单独的应用的使用环境可能和一个用户与用户之间互相影响的应用或者一个单独的平台完全不同。我们其实不是在谈论一个环境；我们在谈论多个环境。让我们看看定义一个成功的移动应用程序必须具备的环境的东西究竟有什么。 硬件。安卓设备的生态系统是一个多样化环境的极好的例子，设备在显示的多方面（物理尺寸、颜色深度、屏幕分辨率、像素密度、长宽比）、输入（轨迹球、触摸屏、物理键盘、麦克风和摄像头）以及能力方面（处理能力、存储、天线等等）显著多样化。 这些属性的结合极大地影响着你的应用程序将如何展示，以及用户可能选择的与它交互的方法的范围。如果如今不存在一个特定的组合，明天也将很有可能出现。一个成功的应用程序必须考虑所有这些硬件设备相关的习惯。 平台的约定。每个平台都有它自己的用户界面约定，通常在人机界面指南文档中描述，在操作系统界面证实。移动Web浏览器的多样性提供了一个典型的例子来展示这些约定可以是怎么样得不同： 一个公共的用户期望是浏览器中“返回”的能力。iOS使用一个虚拟按钮来实现它；安卓和黑莓设备依赖一个物理实体返回按钮；Web操作系统使用一个返回按钮和一个返回手势。无论方法是什么，用户希望在你的应用程序中他们可以“返回”。 用户也期望一个环境菜单。在安卓和黑莓的默认浏览器中，环境菜单通过一个被设立在屏幕底部的物理按键打开，接近拇指的自然的位置。在iOS和Web操作系统中环境菜单通过位于屏幕底部靠近拇指固定存在的虚拟标签栏来打开。这个固定存在于屏幕底部的标签栏在非iOS和Web OS设备中经常产生一个很差的体验因为用户会很容易地误触他们的环境菜单或者返回按钮，造成应用程序意外地被关闭。这些是原生和Web应用程序都必须考虑的限制。 开发人员必须考虑对数据和用户都有良好意义的方法。HTML5不支持菜单元素的概念，所以一个通用的抽象在这里就是可行的，但是它尚未完成。 环境是最大的不确定因素。现在是白天还是夜晚？用户在站着还是坐着？站定还是移动中？一个手空闲还是两个手？在一个繁忙的地方吗？可变性是无限的。 它指引着我们什么方向？从环境中传出来的期望并不是天生跨平台的。原生和Web实现都必须提供设计和代码去支持这些期望。对于Web开发人员来说好消息是他们可以依靠一个熟悉模式在Web技术堆栈中满足用户期望。 实现。为了产生最优的可行的用户体验，实现部分必须在设计和代码上兼顾支持由一个特定的用户环境产生的期望。 性能：软件开发的妖怪 毫无疑问，性能是一份良好用户体验的基石。就像安全性，它是最被误解的，也是软件开发人员的限制使用的替罪羊。不难听到开发人员拒绝一份想法的同时碎碎念：“我们不能这么做，这会对性能造成负面影响。”很少量化，但频繁地引用着一句话：“性能是软件开发的妖怪。”我们如何量化性能？延迟是性能的一种形式。执行，一个操作完成需要的时间，是另一种。我们会分开解决这些事情。 在移动开发世界中，延迟是一个重要的考虑点。不管它是原生应用程序还是一个Web应用程序，在下载一个应用程序以及它通过网络耗费或发布数据时，都会有性能损失。显然，负载越小，应用程序越快速。 使用JavaScript对象表示法（JSON）格式的数据是一个很棒的想法，因为与一个等价的XML负载相比较来说，它会导致更少的数据负载，这取决于XML是如何格式化的。在另一方面，当我们要返回插入Web页面的HTML代码片段，使用XML形式的数据，而非返回JSON形式的数据，当线路较短时，需要使用JavaScript去转换成HTML片段。你面对的情形会不尽相同。基准测试是唯一可以确定结果的方式。 另一个延迟问题是代码初始化时。一旦我们将代码写入内存，它就持续地需要被解析。在这个过程中会有明显的性能损失。我们可以仿造它，并且使用确定或不确定的过程指标来提高对性能的感知。 执行时间，当然，是一个性能的关键指标。解释执行代码（就像我们为Web使用JavaScript）时，有越多的代码需要解释执行，执行时间就越长。Web技术堆栈中还有一些事情需要追赶着去做。JavaScript，它的所有性能的飞跃，仍然比原生的组件要慢。另一方面，一个程序员为了多种移动设备，使用原生的编译型语言去书写类似的逻辑所花费的时间可能是值得的，相对执行时的损耗来说；然而，这实实在在需要更多的维护，相比起使用JavaScript书写，可在多种设备运行的代码来说，同时也许每个平台需要些许调整。更少的代码通常意味着更少和更容易的维护。 有一句话这么讲：“代码的少量对于期待一个良好界面的终端用户来说是无关紧要的。”开发人员的权衡有一个巨大的代码基础，经常容易变得更大，考虑到对多个原生平台的支持。在原生代码的世界中，最大的挑战是重复实现多个目标。在Web的世界中，最大的挑战是尽可能多地限制你的足迹，以产生良好的用户体验。这并不是说一个用户界面可以满足所有的环境。而是，应用程序逻辑的主体在一份代码基础中，然后特定的设备、特定的UI习语可以使用情景化的代码来实现。因此你可以实现不同的功能和用户体验，以适应某个特定设备用户的期望。举个例子，安卓和黑莓设备有物理实体的返回、菜单按钮，而这个iOS设备并没有。 另一个需要记住的重点是即使移动设备工业正在快速的汇集于Web开发工具集，即标准的HTML渲染引擎，每种设备和操作系统都有一个稍微不同的WebKit风格。这意味着你应该期待开发变得和如今的跨浏览器Web开发相似。值得庆幸的是，有许多类库例如jQuery移动、Sencha Touch, 和SproutCore在试图解决这个问题。 所有关于代码延迟和执行的讨论意味着要对你的应用开发主动性的商业目标采取强硬的态度。支持数据装饰是最实用的方法。渐变、阴影、凹凸变化、压花、高亮、圆角以及柏林噪音并不能使应用的可用性增强——它们并不满足商业要求，但他们影响性能。特别是CSS渐变，是移动世界中真正的魔鬼。你需要决定你的目标是什么：看起来整洁还是为数据发布、获取提供一个有用的界面。你在一些平台上通过使用原生代码优化（通常是硬件加速）像素绘制胜过了这些能力中的一部分。这并不是说这些影响不可能实现，而是说他们被明智地使用，也就是当他们能提升、并且不分离用户体验时。提供一个在市场上获得成功的用户体验是有可能的；要求的仅仅是合适的移动开发技术，以及考虑了环境约束的良好的用户体验设计技巧。 可爱的反弹和美丽的设计 当然，美丽的设计很重要。从美学到无形资产，例如一个良好程序的结构，软件设计者必须致力于伟大的设计，并且立足于已经到位的实践。通过动力学物理滑动，可爱的反弹，放松，并且基于此构建有活力的用户界面，它是令人觉得真实的，并且使用它是一件乐事。这是一个原生控制特别良好的领域。 我们还没有使用Web技术圆满地解决原生的滑动问题。但是已经有了许多的尝试：iScroll, TouchScroll, GloveBox, Sencha, 以及jQuery Mobile. 所有这些都致力于解决滑动的问题，但是并没有像原生设备一样那样良好地解决。甚至谷歌的移动团队也在致力于发布一个这个问题的解决办法。毋庸置疑，这是PhoneGap团队最常听到的抱怨，在WebKit出现这个问题之前很久我们就已经是它的问题修复者。谷歌移动团队最近已经发布了基于浏览器和平台的WebKit的解决方式以及代码。 这是纲要。Web技术栈还没有能够达到原生代码可以获得的优良性能表现级别，但正在逐步接近。我们有自信Web技术将会逐渐无区别于原生体验。同时，Web开发者必须在专注于交付数据的同时提高装饰的工作能力。 展望未来 Web和原生在这场辩论中对抗彼此越多，导致的结果很可能是混合的解决方案。或许我们将会看到计算机固有的网络化并且（这是我个人的真诚希望）对于任何人都可以免费访问。我们已经看到原生Web的迹象：WebGL最近证实浏览器运行3D游戏是可行的，甚至运行Quake III! 同时，软件制造商必须平衡Web和原生的对抗，在软件主要的目标、开发、商业现实以及Web技术在不久将来可以提供的机会的基础上。好消息是直到所有技术都被整合进浏览器之前，诸如PhoneGap这类的机构可以帮助弥合鸿沟。我鼓励开发人员不要简单地定义软件开发的趋势，而是实现他们！如果Web不满足你的程序所特定需求的能力，你就获得了一个令人激动的做出贡献的机会，为了弥合Web和原生之间鸿沟的过程做出贡献。 译文：Halo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[让你的图片加载姿势更优美- iOS图片加载的优化]]></title>
      <url>%2F2017%2F04%2F22%2F%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A7%BF%E5%8A%BF%E6%9B%B4%E4%BC%98%E7%BE%8E-%20iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[最近负责使用纯React Native搭建一个新客户端，封装native组件时，对图片加载的方式进行了不同场景的优化，尽可能提高了客户端的性能。 Apple官方为生成一个UIImage对象提供了两种方法： imageNamed，参数为图片的名字 imageWithContentsOfFile，参数是图片文件的路径 根据官方文档： imageNamed imageNamed: 这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象，如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。 不难看出，imageNamed的优点是加载时会缓存图片。所以当图片频繁使用时，用imageNamed方法是比较合适的。如果你的一个TableCiew中每个Cell都需要加载同一个图标，使用该方法，系统会把此图标Cache到内存，每次使用时，图标指针指向同一块内存。这样的图片加载效率是非常高的。 imageWithContentsOfFile 从项目的bundle中，仅加载图片，图像数据不会缓存。 因此，对于比较大的图片以及使用情况较少时，便可使用该方法，降低内存消耗。 两种方法各有优点，在不同场景使用不同的方法，才能有效优化性能。 比如，加载APP的启动loading图片，图片较大，且加载频率很低，很明显使用bundle加载是很合适的。使用imageNamed的举例已在上文提及。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「iTerm」 and 「Oh My Zsh」 配置记录]]></title>
      <url>%2F2017%2F03%2F08%2F%E3%80%8CiTerm%E3%80%8D%20and%20%E3%80%8COh%20My%20Zsh%E3%80%8D%20%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[昨天配置了一下自己的iTerm，最后的效果确实颜值飙升，终端的使用也方便了许多。非常感谢简书的@SuperDanny，本文主要是对他的教程中遇到问题的注解，方便以后查阅。 首先上效果图： 1.下载安装 iTerm 2.将默认bash切换为zsh1chsh -s /bin/zsh 3.cd到根目录，安装oh-my-zsh12cd ~curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 4.留在根目录，安装Powerline这里推荐使用pip安装 1pip install powerline-status --user 添加--user 防止因权限问题安装失败 5.下载、安装字体库 字体库 推荐采用方式为：cd到根目录，clone本项目 cd到项目目录，执行./install.sh，安装所有Powerline字体 安装完成后，可看到提示 1All Powerline fonts installed to /Users/superdanny/Library/Fonts 6.设置iTerm的Regular Font 和 Non-ASCII Font 安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline。 7.配色方案 安装配色方案 进入刚刚下载的工程的solarized/iterm2-colors-solarized 下双击 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 两个文件就可以把配置文件导入到 iTerm中 配置配色方案 通过load presets选择刚刚安装的配色主题即可 8.使用agnoster主题 下载agnoster主题 依旧推荐cd到根目录，clone方式安装 cd到agnoster目录，运行install文件 1open install 设置该主题 在根目录，编辑.zshrc文件 1vim .zshrc 将ZSH_THEME后面的字段改为agnoster。ZSH_THEME=&quot;agnoster&quot;（agnoster即为要设置的主题） 9.增加指令高亮效果—zsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 cd到根目录 clone方式安装项目 再次编辑.zshrc文件，添加下面内容 1source ~/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh cd到plugins目录 1cd ~/.oh-my-zsh/custom/plugins 编辑.zshrc文件 注意，此时在plugins目录下，此zshrc为本目录下的zshrc文件在本zshrc文件中，添加下面内容： 1plugins=(zsh-syntax-highlighting) cd到根目录，执行source指令 1source .zshrc 至此，重启iTerm，即可看到设置生效。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实习技术记录引言]]></title>
      <url>%2F2017%2F02%2F18%2F%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95%E5%BC%95%E8%A8%80%2F</url>
      <content type="text"><![CDATA[最近开始实习工作大概一周了，每天都会接触一些新的东西、有一些新的感悟。这应该是有必要记录下来的。日记的话可能没有办法保证产量，更难保证质量，所以我打算用一个项目作为一篇文章的内容跨度。 工作的内容是对Hybrid相关业务在iOS端提供支持，后期会更多地投入到React Native的项目中。所以，我的记录中的主题会包括：iOS开发，Hybrid，React Native。同时，由于是做框架类的开发，也会记录一些有关框架型项目设计、架构的感悟。 Halo 2017.2.18]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实习记录Vol.1 『下拉显示网页来源特性的添加』]]></title>
      <url>%2F2017%2F02%2F18%2F%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95Vol.1%20%E3%80%8E%E4%B8%8B%E6%8B%89%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E6%9D%A5%E6%BA%90%E7%89%B9%E6%80%A7%E7%9A%84%E6%B7%BB%E5%8A%A0%E3%80%8F%2F</url>
      <content type="text"><![CDATA[『下拉显示网页来源』的实现在最开始先简单介绍一下该效果的实现方式。 这个功能我们在微信中打开链接时、一些手机浏览器中会经常看到，效果如下图： UI实现在做之前查了一下实现方式，常见的一种是将Webview的背景色设为透明，在Webview下层添加一个同样大小的View，用此View的背景色来模拟Webview背景色，在这个View层上贴一个Label用于显示文字。这样在Webview向下滑动时，就会露出后面的网页来源文字。 上面的方法比较直观，但是比较繁琐。我们知道UIWebView对象有一个属性是scrollView，所以可以这样来实现:使用insertSubview方法，在scrollView下面插入一个UILabel。即可实现和上面一样的效果。 123UIWebView *webview = [[UIWebView alloc] init];UILabel *label = [[UILabel alloc] init];[webview insertSubview:label belowSubview:webview.scrollView]; 来源文本加载显示的文本我们一般都会只截取URL的host部分。这里可以使用webview的URL中host部分。 1label.text = webview.request.URL.host; 文本的加载时机一般选择在webview的request加载完成之后。注意对URL字符串进行空判断，如果此时URL为空，则不为文本赋值，也就是此时不显示label。 为Hybrid框架添加此特性功能实现之后，就开始重点了，为框架添加此特性。也就是前端在进行Hybrid App开发时，可以通过Schema或者插件Plugin的方式，对自己的Webview设置是否下拉显示来源。 关于Hybrid入门这里有一篇文章，大家可以先阅读一下。Hybrid入门。 实现方式是在Webview的基类中暴露一个属性，通过调用该属性对应的setter，来对是否显示进行调整。 关于这部分，我总结了以下几点收获。 使用枚举类型表示选项、状态、状态码这是我在《Effective Objective-C 2.0》中读到过的一个建议，顺便向大家推荐一下这本书，书中讲到的52个方法对于我们培养良好的iOS编码习惯有很大的帮助。 在对是否显示此特性进行设置时，我们会用到一些状态码。 12345typedef NS_ENUM(NSInteger, WebSourceShowSate)&#123; WebSourceShowSateNo = 1, WebSourceShowSateYes = 2&#125;; 使用枚举类型的状态码，我们可以通过代码很直观地表示状态。 关于iOS枚举类型的学习，大家可以看这篇 iOS枚举应用。 框架接口设计时，尽量不对外暴露UI相关属性我们在对框架的接口进行设计时，应该努力追求直观、清晰，尽量少暴露内部实现细节。努力让使用者只需关注最简单最直观的内容。所以在这个特性中，我们可以选择将一个上述的状态码或者BOOL类型的属性暴露出来，而非将显示文本的Label对外暴露。 ​ 框架接口设计时，单个参数暴露为属性，多个参数暴露为方法在接口中提供对单个的参数进行设置时，将其设置为属性，使用该属性的setter。 提供对多个参数同时设置时，暴露一个带多个参数的方法。 ​ 利用属性的setter完成一些操作有时候，我们可以通过重写属性的setter，在setter中加入一些操作，使得这些操作能在合适的时机进行。比如本例中， 在Webview实例化之前，想要对此刻还未实例化的Label是否显示进行设置。我们就可以在webview所在类中添加一个标记Label是否进行显示的参数属性。在webview实例化之前，调用该参数属性的setter对其进行赋值，然后在webview的初始化部分对该属性值进行检查，作相应的设置。 在Webview实例化之后，想要在框架接口中，提供对已经实例化的Label是否显示进行设置。我们可以利用前文讲到过的暴露出来的状态码或BOOL型属性，重写该属性的setter，然后在该方法中加入对Label是否显示进行设置的代码。这样就可以在对该状态码赋值的同时，完成相关的UI更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS轻应用推荐之 一键翻墙的 「Lantern」]]></title>
      <url>%2F2017%2F02%2F12%2FMac%20OS%E8%BD%BB%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90%E4%B9%8B%20%E4%B8%80%E9%94%AE%E7%BF%BB%E5%A2%99%E7%9A%84%20%E3%80%8CLantern%E3%80%8D%2F</url>
      <content type="text"><![CDATA[工作或学习时，我们偶尔需要访问被封锁的Google，YouTube等网站。这次为大家推荐一款优秀的一键翻墙软件 ——— Lantern。 简介 Lantern是一款免费的开源软件，它可以帮助我们快速、安全地访问互联网中被封锁的网站。 它的官方网站是 Lantern，目前已被封锁。 刚刚已经说过，它是一款开源软件，相关项目代码已开源在Github中，这里是Github项目地址。 下载 目前最为可靠安全的下载方式为作者在Github中提供的下载地址，包括各个平台的各个版本，这里是官方提供的版本。推荐大家使用这种方式进行下载。这里是下载地址。 使用 下载安装后，打开软件即会在浏览器中弹出以下界面提示你翻墙成功，可以开始尽情访问自己需要的页面了。 原理及安全性 Lantern 让用户能流畅地访问被封锁的互联网站点。Lantern 自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern 通过自有的服务器或者未封锁地区的用户运行的 Lantern 来提供访问。如果网站没有被封锁，Lantern 选择靠边站。这样浏览器就会直接访问网站，而速度不受影响。 Lantern 全程加密被封锁的网站，但如果网站没被封锁，Lantern 不会对其做任何改动。这意味着一个网络上的窥探者，比如政府的审查部门或者 ISP，没办法看到你访问被封锁网站时的具体内容。那些提供访问点的 Lantern 用户能看到你访问的网站，以及你来自哪里。但他们也看不到具体的内容，因为内容是经过HTTPS加密的。Lantern 只给那些提供访问的 Lantern 用户发送 HTTPS加密的内容。 最后，恳请大家在浏览墙外内容的时候，能够保持审视理智的态度~。 Halo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS轻应用推荐系列引言]]></title>
      <url>%2F2017%2F02%2F12%2FMac%20OS%E8%BD%BB%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90%E7%B3%BB%E5%88%97%E5%BC%95%E8%A8%80%2F</url>
      <content type="text"><![CDATA[使用MacBook两年多以来，被推荐或自己发现了一些 Mac OS系统中比较实用或有趣的应用。一直想做一个整理记录，并且分享出来。这个系列就是出于这个目的。我会将使用过的一些优秀应用进行介绍和简单分析。未来遇到的优秀应用我也会在这里持续更新。 在这里『轻应用』的含义是指轻便、易用，类似于浏览器中『插件』的概念，更多的是工具类的应用。所以，开发环境、图形处理等大型软件不在此列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之路之『懒加载』]]></title>
      <url>%2F2017%2F02%2F11%2FiOS%E4%B9%8B%E8%B7%AF%E4%B9%8B%E3%80%8E%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%8F%2F</url>
      <content type="text"><![CDATA[本篇是自己的首篇技术类文章，来谈一谈非常实用的懒加载技术。 首先感谢简书的 @维尼的小熊，他的许多技术文章对我的iOS学习提供了非常大的帮助。 懒加载的定义：延时加载，即当对象需要用到的时候再去加载。其实就是重写对象的get方法,当系统或者开发者调用对象的get方法时，再去加载对象。需要注意：重写get方法时，先判断对象当前是否为空，为空的话再去实例化对象 懒加载的优点: 不需将对象的实例化写到viewDidLoad，可以简化代码，增强代码的可读性 对象的实例化在get方法中，各司其职，降低耦合性 对系统的内存占用率会减小 viewDidLoad正常加载代码示例没用懒加载的时候，从plist获取数据，返回一个数组，需要写在viewDidLoad方法中获取 1234567891011121314151617@interface ViewController ()@property (nonatomic, strong) NSArray *shopData;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;shop&quot; ofType:@&quot;plist&quot;]];&#125;@end 显而易见，当控制器被加载完成后就会加载当前的shopData，假如shopData是在某些事件被触发的时候才会被调用，没必要在控制器加载完就去获取plist文件，如果事件不被触发，代表着shopData永远不会被用到，这样在viewDidLoad中加载shopData就会十分多余，并且耗用内存 懒加载代码示例123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad];&#125;- (NSArray *)shopData&#123; if (!_shopData) &#123; _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;shop&quot; ofType:@&quot;plist&quot;]]; &#125; return _shopData;&#125;@end 当需要用到shopData的时候，就会调用[self shopData]的方法（即get方法），此时系统会去调用get方法，然后再get方法中获取plist文件内容，然后返回使用。 需要注意在get方法里切勿使用self.shopData，因为在这里使用self.shopData会造成死循环。这里涉及到了Objective-C的点语法。self.shopData是方法调用，相当于[self shopData]，也即调用了自身。在Objective-C中，点方法放等号右边就是调用getter，放左边就是调用setter。 总结：懒加载即用到时方去加载对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己写博客文章的几点规范]]></title>
      <url>%2F2017%2F02%2F11%2F%E8%87%AA%E5%B7%B1%E5%86%99%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E5%87%A0%E7%82%B9%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[在md文件起始位置添加正确的标签、分类信息备注12345678910示例---title: # 文章的标题 categories: # 文章的分类 - 杂谈tags: # 这里写的标签会自动汇集到 tags 页面上- 手机- 杂谈- 锤子科技--- 写技术类文章时，段首不缩进。写杂谈、评论等文章时，段首严格缩进。缩进方式：『全角』输入模式下，输入两个空格。 全角切换方式：Shift+ Space tips类语句，短句采用『引用代码』形式，多行采用『引用』形式。 借鉴学习类的博文，在文首正确@原作者表示感谢。 在文章合适的位置对文章进行截断。截断方式：&lt;!-- more --&gt; Halo 2017 2.11]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于罗永浩、关于崇拜偶像]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%85%B3%E4%BA%8E%E7%BD%97%E6%B0%B8%E6%B5%A9%E3%80%81%E5%85%B3%E4%BA%8E%E5%B4%87%E6%8B%9C%E5%81%B6%E5%83%8F%2F</url>
      <content type="text"><![CDATA[为什么想写这一篇 一直以来我都是一个锤粉，是一个罗粉，欣赏老罗的气质、锤子科技的气质，喜欢听老罗的“相声专场”。知乎有很多锤黑，总是贬低着老罗、看衰锤子。以前总是觉得这些无脑黑的人必然水军无误。然而，最近看到了一些老罗负面的记录，说实话，有些讶异，这让我对老罗无比欣赏的态度有了一些改变。也进一步引发了对于崇拜、对于偶像的一些想法。 关于罗永浩、关于崇拜偶像 罗永浩，曾经的新东方明星英文教师，曾创办牛博网。在大多数人质疑、看衰的情况下进军手机制造业，创办锤子科技。在经历了几年的艰难奋斗，最近发布了Smartisan M1系列手机，引发广泛关注。 每个互联网社区都有自己的社区文化。在知乎，“黑老罗”就是这里的文化之一。我记得第一次听到罗永浩这个名字，就是在知乎的一个问题下。那是一个客观讨论罗永浩的问题，下面的答案几乎压倒性的黑他。我好奇，是什么样的一个人会让这么多人都热衷于踩一脚。去百度了一番老罗的履历，感觉这是一个很传奇的人，也仅此而已。可能是被知乎影响吧，最初我对于老罗和他的锤子科技也仅仅是略微了解，同时，抱着不看好的态度。后来闲着无聊在极速上下载锤子的发布会视频，看着看着开始觉得老罗起码是一个有趣的人，饶有兴趣的看完了。之后又下载并且比较认真地看了其他场的发布会。在看的过程中，对锤子科技也有了更进一步的了解。老罗和锤子所宣扬的工匠精神、完美主义、易用主义，噱头也好，情怀也罢，总之就是让我产生了好感，吸引了我去认真了解它的设计、它的Smartisan OS。客观来说，这家企业改变了我对国产手机、国产手机操作系统的认识。然后关注了老罗的微博，开始关注锤子的新闻。老罗所表现出来的性格，所说的话，是很正能量的，宣扬的价值观也能让我认同，慢慢开始了锤粉、罗粉之路。然后锤子在北展剧场开的坚果手机文青版发布会我也和勋哥一起去了现场参加。 迈入粉丝阵营后，再回看知乎上铺天盖地黑老罗的回答，总觉得这些人很无聊，不喜欢是自由，为何要不遗余力地黑呢。也曾给一连串的回答点过反对+没有帮助。我继续听着老罗说相声，看着老罗发微博，然后鄙夷着那些变着花样黑罗的人。 然而，最近看到一篇干货满满的黑罗文章，我承认我有些震惊了。PO主记录了一系列老罗成名早期的言论，直白一点就是，那时候的老罗是一个十足的愤青，而且言语中尽是鄙夷中国的种种言论，近乎无脑地吹捧日本。而且作为公众人物，诸如此类的言论频频在微博上发表。可以说，这样的人在我的意识中一直是被定义为“脑残”的。发现自己崇拜的偶像、欣赏的前辈竟然是自己所鄙夷的那一类人，让我想起了之前知乎一位罗黑讲过的话：“有一种罗黑群体，他们是最早认识罗永浩的那一批人。”是啊，想想看，如果我是在那个时候认识的老罗，我也是确定无疑地会鄙夷反感这个人的吧。 回头看看自己崇拜的老罗，他的演讲堪称风趣风格的教科书级，他在工业设计上强调的工匠精神、精雕细琢，他在硬件、系统中推崇的完美主义、易用主义，他尊重知识产权，他支持开源世界，他身体力行地带着锤子科技改变了这个行业的一些风气，这些都是真实存在的。 再看看他曾经的一系列言论，那些也是真真切切被很多人看在眼里的。也许他已经慢慢改变了想法，不再是那个无脑的愤青喷子，又或许他只是现在作为企业家收敛了自己那些会带来负面效应的作为。其实我更相信后者，因为我不太相信一个中年人的三观会在几年内发生巨大改变。“脑残”的老罗，这也是真实的老罗。 说实话，我一直潜意识地认为老罗在其他方面也是同样美好同样堪称偶像，他热爱着手机行业，我就推断了他也热爱着自己的祖国。这听起来可笑，但它确实在我把老罗当做偶像时在脑海中发生了。我不禁开始想，我们对于偶像的崇拜，到底该持什么样的态度。到目前为止，我还确信，我一直喜欢的老罗的那些特质，都依然真实存在且值得推崇，在这些方面他依然是值得尊重的前辈。但是到了社会观的讨论上，他已经是一个我鄙夷厌恶的对象。这些冲突吗？也许冲突，因为这些让我无法再把他摆在偶像的位置上。但又不冲突，因为我欣赏他在手机行业的成就时无关于对三观的讨论。 归于一句话，我认为对于偶像的崇拜，不必强求他方方面面都值得学习。与此同时，一个人有令你惊叹的一面，不代表他方方面面都同样光芒四射。 所以，当你听说小A的偶像是林丹时，你不能因为林丹出轨就推断小A会对感情不忠，因为小A崇拜的只是林丹打球时的气概。]]></content>
    </entry>

    
  
  
</search>
