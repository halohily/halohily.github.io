<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[移动应用程序开发：Web VS. 原生(译)]]></title>
      <url>%2F2017%2F05%2F14%2FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E6%AF%94%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9B%B4%E4%BE%BF%E5%AE%9C%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E4%BB%AC%E8%83%BD%E5%A4%9F%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%94%9F%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E5%90%97%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[原文《mobile application Development: Web vs. native》,是由Andre Charland和Brian Leroux发布在《Communications of the Acm》的文章，深入探讨了移动领域Web开发和原生开发相关的问题。截止翻译，引用量320。 1Web应用程序的开发和部署比原生应用程序更便宜，但是它们能够匹配原生用户体验吗？ 移动应用程序开发：Web VS. 原生 短短几年前，大多数的移动设备，想要使用一个更贴切的词语来形容，是“哑的”。当然，也有一些早期的智能手机，但是他们要么是邮件集中，要么就是缺乏一个可以不用小尖笔就可以使用的先进触摸屏。附带一个有能力显示任何东西，不止是简单的文本，链接，或者是一个图像的像样的手机浏览器的就更少了.这意味着如果你有这些设备之一，你要么是一个沉迷于电子邮件的商人，要么是一个希望这是智能手机之年的最初的极客。之后苹果用iPhone的发布改变了一切，同时我们对于移动设备使用体验的预期被完全重设。 最初对于第三方iPhone应用程序的计划是使用开放的Web技术。苹果甚至为它的Dashcode项目发布了工具。快速向前发展的三年，原生应用程序大大流行。通常，就工作性能的原因来看，相比较来说移动Web正在变得不是最适宜的。 顺着这一条思考的路线有两个问题。首先，如果使用各自的原生语言来为不同平台构建应用程序是非常昂贵的。一个独立游戏开发者或者启动很有可能只可以支持一种设备，就像iPhone，但是一个IT部门必须支持它的用户的所有设备，即使它们不总是最新的和最好的。第二，原生应用程序适用于3D游戏或者图像处理时更快速的性能表现相关的争论，而且在一个使用Web技术良好构建的商业应用中有微小的、不引人注意的性能损失。 就其本身而言，谷歌正在为使用Web技术去解决平台分裂化问题押注。谷歌负责工程的副总裁，声称 “连谷歌也没有足够的钱去支持所有的不同的移动平台—从苹果的应用程序商店到黑莓、Windows移动操作系统、安卓，以及诺基亚平台的许多变种”。并且这是在惠普Web操作系统、MeeGo和其他平台问世之前。 在本文中，我们讨论Web和原生方法的一些优势和缺点，伴随着对于Web技术和它对应的原生同作用事务之间沟壑正在缩小的领域的特别关注。 原生代码 VS. Web代码 实现一个软件应用程序从代码开始。在原生代码的情况下，大多数时候开发者通常用C语言系列，就像在开发iPhone应用程序的情况下。在我们在Nitobi和PhoneGap上的工作中，我们已经有足够的经验从一个原生开发者的角度去应对多样变化的移动平台。 当然，由于多样变化的市场，或者是由于组织化的原因，大多数的开发者或者团队必须支持多个智能手机平台的应用程序。想要用原生代码写一个应用程序然后面对每一个单独的移动操作系统？没有问题，如果你的团队具有附带表格所展示的技能集。 使事情变得更复杂的是实际的平台开发工具集之间的不同。有不同的工具、构建系统、应用程序编程接口，以及对于每个平台有不同能力的设备。事实上，这些操作系统共同拥有的唯一事物是它们都附带一个可以编程化访问原生代码的移动浏览器。 每个平台都允许我们实例化一个浏览器实例，更简洁，并且可以使用它的JavaScript接口与原生代码相互配合。从Webview中我们可以通过JavaScript调用原生代码。这种攻击作为PhoneGap技术开始成名，由Eric Oesterle，Rob Ellis和Brock开创，于2008年在iPhone开发营为iPhone操作系统下开发工具集而写。这种方法后来被移植到安卓、黑莓，以及其他支持PhoneGap的平台。PhoneGap是一个开源的框架，它提供给开发者一个他们可以使用HTML、CSS和JavaScript来开发移动应用程序的环境，并且仍然可以通过通用的JavaScript接口调用原生的设备特性和传感器。PhoneGap框架包含原生代码片段，用来和底层操作系统互相配合以及传递信息给运行在Webview容器中的JavaScript应用程序。如今，有对地理定位、加速度计的支持，以及其他的许多。 那么原生代码到底是什么？它通常是编译型语言，比解释型语言例如JavaScript运行得更快。Webview浏览器使用HTML和CSS构建用户界面，具有不同程度的能力和成功。使用原生代码，我们可以通过专有的应用程序编程接口直接在屏幕上绘制像素，还可以抽象化通用的用户界面元素和控件。 简而言之，我们在让JavaScript和编译型语言较量。如今，JavaScript持有它自己。这并不令人惊异——JavaScript虚拟机技术是如今新的浏览器战争的前线。微软、谷歌、苹果、Opera和Mozilla都在激烈地反复迭代，竞争着完成实现。现在，通过一些基准，Mozilla的”蜘蛛-猴子“正在接近谷歌的V8引擎。苹果的JavaScriptCore，在大多数的WebKit浏览器（使用于数量最多的移动设备上）中建立，并介于其中。底线是所有主要参与者的沉重开支正在为这场JavaScript军备竞赛添火加柴。Ars Technica的基准图1是这些企业是如何推销自己的一个例子。 JavaScript正在迅速地变得更快——如此得快，事实上，惠普的Palm Web操作系统2.0版本重写了它的服务层，原来是Java，现在是极其受欢迎的node.js平台，它是构建于谷歌的V8引擎上并且在更低的CPU消耗下有更好的性能表现（因此具有更长的电池使用时间）。我们所能见到的趋势是Web技术栈运行在低水平，并且相应地在今天数以百万计的设备上。 用户界面代码 当谈到用户界面时，事情并不那么美好。大多数原生平台有通用用户界面控件和体验的极好的抽象。没有两个平台有一样的，甚至相似的用户界面模式，更不用说单独使用应用程序编程接口去实例化和访问它们。Web平台在大多数情况下是一致的，但是内建的或者开发工具集包含的控件的数量是有限的。你必须去自己开始工作。有时浏览器之间的不同会造成烦恼，但是至少在现代智能手机的世界中，大多数设备运行着最能干WebKit渲染引擎，而且它们之间只有微小的差异。 不幸的是，对于Web来说，那些微小的差异正在变成大问题。举个例子，在iOS中，CSS位置属性不能正确地支持一个“xed”的值。（这曾是安卓中的一个问题，但是已经在最新的安卓2.2代码中被修正。）黑莓操作系统在6.0版本之前运行着一个完全神秘的浏览器，对于Web开发人员的心智健康造成很多辛劳，也遭受很多痛苦。幸运的是，RIM在6.0版本中已经解决了很多类似的事情，并且一般来说，事情会变得越来越好。 一些操作系统包含一些叫做硬件加速的事物。iOS堆栈非常著名地支持了这个CSS转换的概念，这是关于Web框架如何顺畅地在视图状态之间转换。这是一个首先在Dashcode中被发明的技术。它由David Kaneda煞费苦心地反向工程化，在jQTouch上开创，并且后来在Sencha Touch发布。它们都是令人难以置信的Web项目，同时也是当开发人员推动边界时什么事情可以被完成的例子。 当我们首先开始利用这些下一代的移动浏览器时，没有什么框架可以在不同设备之间正确地工作。如今有超过20种的移动框架，并且相关支持正在被快速地添加到已有的文档对象模型库中——不止是John Resig的jQuery，还有jQuery移动版；那些代码正在被不断地完善，并且每天都在为更多的设备添加支持。有了这些类似的工具，从一个单独的面向Web的代码库去支持多个目标变得越来越容易。 当把Web技术栈和原生代码比较时，快速执行和漂亮的用户界面并不是故事的全部。Web技术存在于沙盒，这也是原生代码可以访问的低级API的笼子——可以访问设备存储、传感器和数据的API。但是这一沟壑也正在被弥合。如今大多数移动浏览器支持地理定位，举个例子，iOS最近增加了加速度计和一些其他的HTML5应用程序编程接口。考虑到W3C有一个设备API工作组，就好像我们在不久的将来将会看到许多连至浏览器的API。如果这个很近的将来不是足够短的话，现在你可以使用PhoneGap来获取这些API。 当然，Web技术堆栈(HTML/CSS/JS)本身就是用原生代码实现的。原生层和浏览器之间的距离就只是一个编译而已。换句话说，如果你想给一个浏览器添加一个原生的能力，你也可以桥接它或者重新编译这个浏览器以获得那个能力。如果一个浏览器不支持一个原生的能力，不是因为它确实不能，也不是因为它不愿意；它只是意味着它尚未完成。 用户体验：上下文环境与实现 另一个对原生和Web移动应用程序开发都有重大影响的领域是用户体验，我们使用这个术语来描述用户使用一个软件应用程序期间的全面的体验。用户体验甚至可以扩展到应用程序之外。举个例子，我们在某些情况下发送通知去唤醒一个应用程序，比如一个地理位置的变化，或者产生一个专用的应用程序去处理不同的应用方面。显然，一个成功的用户体验是采用成功应用的关键。 一般来说，一个移动软件项目的用户体验可以分为两个主要类别： 环境 元素必须能够被理解，但是不能被改变或者被控制。这些包括硬件功能，平台能力和用户界面规范，以及应用程序被使用的环境。 实现 在一个应用程序中可以被控制的元素，比如性能，设计以及集成平台特性，例如加速度计的数据或者通知。 你的应用程序将被使用的环境影响着用户的预期。单独的应用的使用环境可能和一个用户与用户之间互相影响的应用或者一个单独的平台完全不同。我们其实不是在谈论一个环境；我们在谈论多个环境。让我们看看定义一个成功的移动应用程序必须具备的环境的东西究竟有什么。 硬件。安卓设备的生态系统是一个多样化环境的极好的例子，设备在显示的多方面（物理尺寸、颜色深度、屏幕分辨率、像素密度、长宽比）、输入（轨迹球、触摸屏、物理键盘、麦克风和摄像头）以及能力方面（处理能力、存储、天线等等）显著多样化。 这些属性的结合极大地影响着你的应用程序将如何展示，以及用户可能选择的与它交互的方法的范围。如果如今不存在一个特定的组合，明天也将很有可能出现。一个成功的应用程序必须考虑所有这些硬件设备相关的习惯。 平台的约定。每个平台都有它自己的用户界面约定，通常在人机界面指南文档中描述，在操作系统界面证实。移动Web浏览器的多样性提供了一个典型的例子来展示这些约定可以是怎么样得不同： 一个公共的用户期望是浏览器中“返回”的能力。iOS使用一个虚拟按钮来实现它；安卓和黑莓设备依赖一个物理实体返回按钮；Web操作系统使用一个返回按钮和一个返回手势。无论方法是什么，用户希望在你的应用程序中他们可以“返回”。 用户也期望一个环境菜单。在安卓和黑莓的默认浏览器中，环境菜单通过一个被设立在屏幕底部的物理按键打开，接近拇指的自然的位置。在iOS和Web操作系统中环境菜单通过位于屏幕底部靠近拇指固定存在的虚拟标签栏来打开。这个固定存在于屏幕底部的标签栏在非iOS和Web OS设备中经常产生一个很差的体验因为用户会很容易地误触他们的环境菜单或者返回按钮，造成应用程序意外地被关闭。这些是原生和Web应用程序都必须考虑的限制。 开发人员必须考虑对数据和用户都有良好意义的方法。HTML5不支持菜单元素的概念，所以一个通用的抽象在这里就是可行的，但是它尚未完成。 环境是最大的不确定因素。现在是白天还是夜晚？用户在站着还是坐着？站定还是移动中？一个手空闲还是两个手？在一个繁忙的地方吗？可变性是无限的。 它指引着我们什么方向？从环境中传出来的期望并不是天生跨平台的。原生和Web实现都必须提供设计和代码去支持这些期望。对于Web开发人员来说好消息是他们可以依靠一个熟悉模式在Web技术堆栈中满足用户期望。 实现。为了产生最优的可行的用户体验，实现部分必须在设计和代码上兼顾支持由一个特定的用户环境产生的期望。 性能：软件开发的妖怪 毫无疑问，性能是一份良好用户体验的基石。就像安全性，它是最被误解的，也是软件开发人员的限制使用的替罪羊。不难听到开发人员拒绝一份想法的同时碎碎念：“我们不能这么做，这会对性能造成负面影响。”很少量化，但频繁地引用着一句话：“性能是软件开发的妖怪。”我们如何量化性能？延迟是性能的一种形式。执行，一个操作完成需要的时间，是另一种。我们会分开解决这些事情。 在移动开发世界中，延迟是一个重要的考虑点。不管它是原生应用程序还是一个Web应用程序，在下载一个应用程序以及它通过网络耗费或发布数据时，都会有性能损失。显然，负载越小，应用程序越快速。 使用JavaScript对象表示法（JSON）格式的数据是一个很棒的想法，因为与一个等价的XML负载相比较来说，它会导致更少的数据负载，这取决于XML是如何格式化的。在另一方面，当我们要返回插入Web页面的HTML代码片段，使用XML形式的数据，而非返回JSON形式的数据，当线路较短时，需要使用JavaScript去转换成HTML片段。你面对的情形会不尽相同。基准测试是唯一可以确定结果的方式。 另一个延迟问题是代码初始化时。一旦我们将代码写入内存，它就持续地需要被解析。在这个过程中会有明显的性能损失。我们可以仿造它，并且使用确定或不确定的过程指标来提高对性能的感知。 执行时间，当然，是一个性能的关键指标。解释执行代码（就像我们为Web使用JavaScript）时，有越多的代码需要解释执行，执行时间就越长。Web技术堆栈中还有一些事情需要追赶着去做。JavaScript，它的所有性能的飞跃，仍然比原生的组件要慢。另一方面，一个程序员为了多种移动设备，使用原生的编译型语言去书写类似的逻辑所花费的时间可能是值得的，相对执行时的损耗来说；然而，这实实在在需要更多的维护，相比起使用JavaScript书写，可在多种设备运行的代码来说，同时也许每个平台需要些许调整。更少的代码通常意味着更少和更容易的维护。 有一句话这么讲：“代码的少量对于期待一个良好界面的终端用户来说是无关紧要的。”开发人员的权衡有一个巨大的代码基础，经常容易变得更大，考虑到对多个原生平台的支持。在原生代码的世界中，最大的挑战是重复实现多个目标。在Web的世界中，最大的挑战是尽可能多地限制你的足迹，以产生良好的用户体验。这并不是说一个用户界面可以满足所有的环境。而是，应用程序逻辑的主体在一份代码基础中，然后特定的设备、特定的UI习语可以使用情景化的代码来实现。因此你可以实现不同的功能和用户体验，以适应某个特定设备用户的期望。举个例子，安卓和黑莓设备有物理实体的返回、菜单按钮，而这个iOS设备并没有。 另一个需要记住的重点是即使移动设备工业正在快速的汇集于Web开发工具集，即标准的HTML渲染引擎，每种设备和操作系统都有一个稍微不同的WebKit风格。这意味着你应该期待开发变得和如今的跨浏览器Web开发相似。值得庆幸的是，有许多类库例如jQuery移动、Sencha Touch, 和SproutCore在试图解决这个问题。 所有关于代码延迟和执行的讨论意味着要对你的应用开发主动性的商业目标采取强硬的态度。支持数据装饰是最实用的方法。渐变、阴影、凹凸变化、压花、高亮、圆角以及柏林噪音并不能使应用的可用性增强——它们并不满足商业要求，但他们影响性能。特别是CSS渐变，是移动世界中真正的魔鬼。你需要决定你的目标是什么：看起来整洁还是为数据发布、获取提供一个有用的界面。你在一些平台上通过使用原生代码优化（通常是硬件加速）像素绘制胜过了这些能力中的一部分。这并不是说这些影响不可能实现，而是说他们被明智地使用，也就是当他们能提升、并且不分离用户体验时。提供一个在市场上获得成功的用户体验是有可能的；要求的仅仅是合适的移动开发技术，以及考虑了环境约束的良好的用户体验设计技巧。 可爱的反弹和美丽的设计 当然，美丽的设计很重要。从美学到无形资产，例如一个良好程序的结构，软件设计者必须致力于伟大的设计，并且立足于已经到位的实践。通过动力学物理滑动，可爱的反弹，放松，并且基于此构建有活力的用户界面，它是令人觉得真实的，并且使用它是一件乐事。这是一个原生控制特别良好的领域。 我们还没有使用Web技术圆满地解决原生的滑动问题。但是已经有了许多的尝试：iScroll, TouchScroll, GloveBox, Sencha, 以及jQuery Mobile. 所有这些都致力于解决滑动的问题，但是并没有像原生设备一样那样良好地解决。甚至谷歌的移动团队也在致力于发布一个这个问题的解决办法。毋庸置疑，这是PhoneGap团队最常听到的抱怨，在WebKit出现这个问题之前很久我们就已经是它的问题修复者。谷歌移动团队最近已经发布了基于浏览器和平台的WebKit的解决方式以及代码。 这是纲要。Web技术栈还没有能够达到原生代码可以获得的优良性能表现级别，但正在逐步接近。我们有自信Web技术将会逐渐无区别于原生体验。同时，Web开发者必须在专注于交付数据的同时提高装饰的工作能力。 展望未来 Web和原生在这场辩论中对抗彼此越多，导致的结果很可能是混合的解决方案。或许我们将会看到计算机固有的网络化并且（这是我个人的真诚希望）对于任何人都可以免费访问。我们已经看到原生Web的迹象：WebGL最近证实浏览器运行3D游戏是可行的，甚至运行Quake III! 同时，软件制造商必须平衡Web和原生的对抗，在软件主要的目标、开发、商业现实以及Web技术在不久将来可以提供的机会的基础上。好消息是直到所有技术都被整合进浏览器之前，诸如PhoneGap这类的机构可以帮助弥合鸿沟。我鼓励开发人员不要简单地定义软件开发的趋势，而是实现他们！如果Web不满足你的程序所特定需求的能力，你就获得了一个令人激动的做出贡献的机会，为了弥合Web和原生之间鸿沟的过程做出贡献。 译文：Halo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[让你的图片加载姿势更优美- iOS图片加载的优化]]></title>
      <url>%2F2017%2F04%2F22%2F%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A7%BF%E5%8A%BF%E6%9B%B4%E4%BC%98%E7%BE%8E-%20iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[最近负责使用纯React Native搭建一个新客户端，封装native组件时，对图片加载的方式进行了不同场景的优化，尽可能提高了客户端的性能。 Apple官方为生成一个UIImage对象提供了两种方法： imageNamed，参数为图片的名字 imageWithContentsOfFile，参数是图片文件的路径 根据官方文档： imageNamed imageNamed: 这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象，如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。 不难看出，imageNamed的优点是加载时会缓存图片。所以当图片频繁使用时，用imageNamed方法是比较合适的。如果你的一个TableCiew中每个Cell都需要加载同一个图标，使用该方法，系统会把此图标Cache到内存，每次使用时，图标指针指向同一块内存。这样的图片加载效率是非常高的。 imageWithContentsOfFile 从项目的bundle中，仅加载图片，图像数据不会缓存。 因此，对于比较大的图片以及使用情况较少时，便可使用该方法，降低内存消耗。 两种方法各有优点，在不同场景使用不同的方法，才能有效优化性能。 比如，加载APP的启动loading图片，图片较大，且加载频率很低，很明显使用bundle加载是很合适的。使用imageNamed的举例已在上文提及。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[「iTerm」 and 「Oh My Zsh」 配置记录]]></title>
      <url>%2F2017%2F03%2F08%2F%E3%80%8CiTerm%E3%80%8D%20and%20%E3%80%8COh%20My%20Zsh%E3%80%8D%20%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[昨天配置了一下自己的iTerm，最后的效果确实颜值飙升，终端的使用也方便了许多。非常感谢简书的@SuperDanny，本文主要是对他的教程中遇到问题的注解，方便以后查阅。 首先上效果图： 1.下载安装 iTerm 2.将默认bash切换为zsh1chsh -s /bin/zsh 3.cd到根目录，安装oh-my-zsh12cd ~curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 4.留在根目录，安装Powerline这里推荐使用pip安装 1pip install powerline-status --user 添加--user 防止因权限问题安装失败 5.下载、安装字体库 字体库 推荐采用方式为：cd到根目录，clone本项目 cd到项目目录，执行./install.sh，安装所有Powerline字体 安装完成后，可看到提示 1All Powerline fonts installed to /Users/superdanny/Library/Fonts 6.设置iTerm的Regular Font 和 Non-ASCII Font 安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline。 7.配色方案 安装配色方案 进入刚刚下载的工程的solarized/iterm2-colors-solarized 下双击 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 两个文件就可以把配置文件导入到 iTerm中 配置配色方案 通过load presets选择刚刚安装的配色主题即可 8.使用agnoster主题 下载agnoster主题 依旧推荐cd到根目录，clone方式安装 cd到agnoster目录，运行install文件 1open install 设置该主题 在根目录，编辑.zshrc文件 1vim .zshrc 将ZSH_THEME后面的字段改为agnoster。ZSH_THEME=&quot;agnoster&quot;（agnoster即为要设置的主题） 9.增加指令高亮效果—zsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 cd到根目录 clone方式安装项目 再次编辑.zshrc文件，添加下面内容 1source ~/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh cd到plugins目录 1cd ~/.oh-my-zsh/custom/plugins 编辑.zshrc文件 注意，此时在plugins目录下，此zshrc为本目录下的zshrc文件在本zshrc文件中，添加下面内容： 1plugins=(zsh-syntax-highlighting) cd到根目录，执行source指令 1source .zshrc 至此，重启iTerm，即可看到设置生效。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实习记录Vol.1 『下拉显示网页来源特性的添加』]]></title>
      <url>%2F2017%2F02%2F18%2F%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95Vol.1%20%E3%80%8E%E4%B8%8B%E6%8B%89%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E6%9D%A5%E6%BA%90%E7%89%B9%E6%80%A7%E7%9A%84%E6%B7%BB%E5%8A%A0%E3%80%8F%2F</url>
      <content type="text"><![CDATA[『下拉显示网页来源』的实现在最开始先简单介绍一下该效果的实现方式。 这个功能我们在微信中打开链接时、一些手机浏览器中会经常看到，效果如下图： UI实现在做之前查了一下实现方式，常见的一种是将Webview的背景色设为透明，在Webview下层添加一个同样大小的View，用此View的背景色来模拟Webview背景色，在这个View层上贴一个Label用于显示文字。这样在Webview向下滑动时，就会露出后面的网页来源文字。 上面的方法比较直观，但是比较繁琐。我们知道UIWebView对象有一个属性是scrollView，所以可以这样来实现:使用insertSubview方法，在scrollView下面插入一个UILabel。即可实现和上面一样的效果。 123UIWebView *webview = [[UIWebView alloc] init];UILabel *label = [[UILabel alloc] init];[webview insertSubview:label belowSubview:webview.scrollView]; 来源文本加载显示的文本我们一般都会只截取URL的host部分。这里可以使用webview的URL中host部分。 1label.text = webview.request.URL.host; 文本的加载时机一般选择在webview的request加载完成之后。注意对URL字符串进行空判断，如果此时URL为空，则不为文本赋值，也就是此时不显示label。 为Hybrid框架添加此特性功能实现之后，就开始重点了，为框架添加此特性。也就是前端在进行Hybrid App开发时，可以通过Schema或者插件Plugin的方式，对自己的Webview设置是否下拉显示来源。 关于Hybrid入门这里有一篇文章，大家可以先阅读一下。Hybrid入门。 实现方式是在Webview的基类中暴露一个属性，通过调用该属性对应的setter，来对是否显示进行调整。 关于这部分，我总结了以下几点收获。 使用枚举类型表示选项、状态、状态码这是我在《Effective Objective-C 2.0》中读到过的一个建议，顺便向大家推荐一下这本书，书中讲到的52个方法对于我们培养良好的iOS编码习惯有很大的帮助。 在对是否显示此特性进行设置时，我们会用到一些状态码。 12345typedef NS_ENUM(NSInteger, WebSourceShowSate)&#123; WebSourceShowSateNo = 1, WebSourceShowSateYes = 2&#125;; 使用枚举类型的状态码，我们可以通过代码很直观地表示状态。 关于iOS枚举类型的学习，大家可以看这篇 iOS枚举应用。 框架接口设计时，尽量不对外暴露UI相关属性我们在对框架的接口进行设计时，应该努力追求直观、清晰，尽量少暴露内部实现细节。努力让使用者只需关注最简单最直观的内容。所以在这个特性中，我们可以选择将一个上述的状态码或者BOOL类型的属性暴露出来，而非将显示文本的Label对外暴露。 ​ 框架接口设计时，单个参数暴露为属性，多个参数暴露为方法在接口中提供对单个的参数进行设置时，将其设置为属性，使用该属性的setter。 提供对多个参数同时设置时，暴露一个带多个参数的方法。 ​ 利用属性的setter完成一些操作有时候，我们可以通过重写属性的setter，在setter中加入一些操作，使得这些操作能在合适的时机进行。比如本例中， 在Webview实例化之前，想要对此刻还未实例化的Label是否显示进行设置。我们就可以在webview所在类中添加一个标记Label是否进行显示的参数属性。在webview实例化之前，调用该参数属性的setter对其进行赋值，然后在webview的初始化部分对该属性值进行检查，作相应的设置。 在Webview实例化之后，想要在框架接口中，提供对已经实例化的Label是否显示进行设置。我们可以利用前文讲到过的暴露出来的状态码或BOOL型属性，重写该属性的setter，然后在该方法中加入对Label是否显示进行设置的代码。这样就可以在对该状态码赋值的同时，完成相关的UI更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实习技术记录引言]]></title>
      <url>%2F2017%2F02%2F18%2F%E5%AE%9E%E4%B9%A0%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95%E5%BC%95%E8%A8%80%2F</url>
      <content type="text"><![CDATA[最近开始实习工作大概一周了，每天都会接触一些新的东西、有一些新的感悟。这应该是有必要记录下来的。日记的话可能没有办法保证产量，更难保证质量，所以我打算用一个项目作为一篇文章的内容跨度。 工作的内容是对Hybrid相关业务在iOS端提供支持，后期会更多地投入到React Native的项目中。所以，我的记录中的主题会包括：iOS开发，Hybrid，React Native。同时，由于是做框架类的开发，也会记录一些有关框架型项目设计、架构的感悟。 Halo 2017.2.18]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS轻应用推荐之 一键翻墙的 「Lantern」]]></title>
      <url>%2F2017%2F02%2F12%2FMac%20OS%E8%BD%BB%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90%E4%B9%8B%20%E4%B8%80%E9%94%AE%E7%BF%BB%E5%A2%99%E7%9A%84%20%E3%80%8CLantern%E3%80%8D%2F</url>
      <content type="text"><![CDATA[工作或学习时，我们偶尔需要访问被封锁的Google，YouTube等网站。这次为大家推荐一款优秀的一键翻墙软件 ——— Lantern。 简介 Lantern是一款免费的开源软件，它可以帮助我们快速、安全地访问互联网中被封锁的网站。 它的官方网站是 Lantern，目前已被封锁。 刚刚已经说过，它是一款开源软件，相关项目代码已开源在Github中，这里是Github项目地址。 下载 目前最为可靠安全的下载方式为作者在Github中提供的下载地址，包括各个平台的各个版本，这里是官方提供的版本。推荐大家使用这种方式进行下载。这里是下载地址。 使用 下载安装后，打开软件即会在浏览器中弹出以下界面提示你翻墙成功，可以开始尽情访问自己需要的页面了。 原理及安全性 Lantern 让用户能流畅地访问被封锁的互联网站点。Lantern 自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern 通过自有的服务器或者未封锁地区的用户运行的 Lantern 来提供访问。如果网站没有被封锁，Lantern 选择靠边站。这样浏览器就会直接访问网站，而速度不受影响。 Lantern 全程加密被封锁的网站，但如果网站没被封锁，Lantern 不会对其做任何改动。这意味着一个网络上的窥探者，比如政府的审查部门或者 ISP，没办法看到你访问被封锁网站时的具体内容。那些提供访问点的 Lantern 用户能看到你访问的网站，以及你来自哪里。但他们也看不到具体的内容，因为内容是经过HTTPS加密的。Lantern 只给那些提供访问的 Lantern 用户发送 HTTPS加密的内容。 最后，恳请大家在浏览墙外内容的时候，能够保持审视理智的态度~。 Halo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS轻应用推荐系列引言]]></title>
      <url>%2F2017%2F02%2F12%2FMac%20OS%E8%BD%BB%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90%E7%B3%BB%E5%88%97%E5%BC%95%E8%A8%80%2F</url>
      <content type="text"><![CDATA[使用MacBook两年多以来，被推荐或自己发现了一些 Mac OS系统中比较实用或有趣的应用。一直想做一个整理记录，并且分享出来。这个系列就是出于这个目的。我会将使用过的一些优秀应用进行介绍和简单分析。未来遇到的优秀应用我也会在这里持续更新。 在这里『轻应用』的含义是指轻便、易用，类似于浏览器中『插件』的概念，更多的是工具类的应用。所以，开发环境、图形处理等大型软件不在此列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之路之『懒加载』]]></title>
      <url>%2F2017%2F02%2F11%2FiOS%E4%B9%8B%E8%B7%AF%E4%B9%8B%E3%80%8E%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%8F%2F</url>
      <content type="text"><![CDATA[本篇是自己的首篇技术类文章，来谈一谈非常实用的懒加载技术。 首先感谢简书的 @维尼的小熊，他的许多技术文章对我的iOS学习提供了非常大的帮助。 懒加载的定义：延时加载，即当对象需要用到的时候再去加载。其实就是重写对象的get方法,当系统或者开发者调用对象的get方法时，再去加载对象。需要注意：重写get方法时，先判断对象当前是否为空，为空的话再去实例化对象 懒加载的优点: 不需将对象的实例化写到viewDidLoad，可以简化代码，增强代码的可读性 对象的实例化在get方法中，各司其职，降低耦合性 对系统的内存占用率会减小 viewDidLoad正常加载代码示例没用懒加载的时候，从plist获取数据，返回一个数组，需要写在viewDidLoad方法中获取 1234567891011121314151617@interface ViewController ()@property (nonatomic, strong) NSArray *shopData;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;shop&quot; ofType:@&quot;plist&quot;]];&#125;@end 显而易见，当控制器被加载完成后就会加载当前的shopData，假如shopData是在某些事件被触发的时候才会被调用，没必要在控制器加载完就去获取plist文件，如果事件不被触发，代表着shopData永远不会被用到，这样在viewDidLoad中加载shopData就会十分多余，并且耗用内存 懒加载代码示例123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad];&#125;- (NSArray *)shopData&#123; if (!_shopData) &#123; _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;shop&quot; ofType:@&quot;plist&quot;]]; &#125; return _shopData;&#125;@end 当需要用到shopData的时候，就会调用[self shopData]的方法（即get方法），此时系统会去调用get方法，然后再get方法中获取plist文件内容，然后返回使用。 需要注意在get方法里切勿使用self.shopData，因为在这里使用self.shopData会造成死循环。这里涉及到了Objective-C的点语法。self.shopData是方法调用，相当于[self shopData]，也即调用了自身。在Objective-C中，点方法放等号右边就是调用getter，放左边就是调用setter。 总结：懒加载即用到时方去加载对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己写博客文章的几点规范]]></title>
      <url>%2F2017%2F02%2F11%2F%E8%87%AA%E5%B7%B1%E5%86%99%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E5%87%A0%E7%82%B9%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[在md文件起始位置添加正确的标签、分类信息备注12345678910示例---title: # 文章的标题 categories: # 文章的分类 - 杂谈tags: # 这里写的标签会自动汇集到 tags 页面上- 手机- 杂谈- 锤子科技--- 写技术类文章时，段首不缩进。写杂谈、评论等文章时，段首严格缩进。缩进方式：『全角』输入模式下，输入两个空格。 全角切换方式：Shift+ Space tips类语句，短句采用『引用代码』形式，多行采用『引用』形式。 借鉴学习类的博文，在文首正确@原作者表示感谢。 在文章合适的位置对文章进行截断。截断方式：&lt;!-- more --&gt; Halo 2017 2.11]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于罗永浩、关于崇拜偶像]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%85%B3%E4%BA%8E%E7%BD%97%E6%B0%B8%E6%B5%A9%E3%80%81%E5%85%B3%E4%BA%8E%E5%B4%87%E6%8B%9C%E5%81%B6%E5%83%8F%2F</url>
      <content type="text"><![CDATA[为什么想写这一篇 一直以来我都是一个锤粉，是一个罗粉，欣赏老罗的气质、锤子科技的气质，喜欢听老罗的“相声专场”。知乎有很多锤黑，总是贬低着老罗、看衰锤子。以前总是觉得这些无脑黑的人必然水军无误。然而，最近看到了一些老罗负面的记录，说实话，有些讶异，这让我对老罗无比欣赏的态度有了一些改变。也进一步引发了对于崇拜、对于偶像的一些想法。 关于罗永浩、关于崇拜偶像 罗永浩，曾经的新东方明星英文教师，曾创办牛博网。在大多数人质疑、看衰的情况下进军手机制造业，创办锤子科技。在经历了几年的艰难奋斗，最近发布了Smartisan M1系列手机，引发广泛关注。 每个互联网社区都有自己的社区文化。在知乎，“黑老罗”就是这里的文化之一。我记得第一次听到罗永浩这个名字，就是在知乎的一个问题下。那是一个客观讨论罗永浩的问题，下面的答案几乎压倒性的黑他。我好奇，是什么样的一个人会让这么多人都热衷于踩一脚。去百度了一番老罗的履历，感觉这是一个很传奇的人，也仅此而已。可能是被知乎影响吧，最初我对于老罗和他的锤子科技也仅仅是略微了解，同时，抱着不看好的态度。后来闲着无聊在极速上下载锤子的发布会视频，看着看着开始觉得老罗起码是一个有趣的人，饶有兴趣的看完了。之后又下载并且比较认真地看了其他场的发布会。在看的过程中，对锤子科技也有了更进一步的了解。老罗和锤子所宣扬的工匠精神、完美主义、易用主义，噱头也好，情怀也罢，总之就是让我产生了好感，吸引了我去认真了解它的设计、它的Smartisan OS。客观来说，这家企业改变了我对国产手机、国产手机操作系统的认识。然后关注了老罗的微博，开始关注锤子的新闻。老罗所表现出来的性格，所说的话，是很正能量的，宣扬的价值观也能让我认同，慢慢开始了锤粉、罗粉之路。然后锤子在北展剧场开的坚果手机文青版发布会我也和勋哥一起去了现场参加。 迈入粉丝阵营后，再回看知乎上铺天盖地黑老罗的回答，总觉得这些人很无聊，不喜欢是自由，为何要不遗余力地黑呢。也曾给一连串的回答点过反对+没有帮助。我继续听着老罗说相声，看着老罗发微博，然后鄙夷着那些变着花样黑罗的人。 然而，最近看到一篇干货满满的黑罗文章，我承认我有些震惊了。PO主记录了一系列老罗成名早期的言论，直白一点就是，那时候的老罗是一个十足的愤青，而且言语中尽是鄙夷中国的种种言论，近乎无脑地吹捧日本。而且作为公众人物，诸如此类的言论频频在微博上发表。可以说，这样的人在我的意识中一直是被定义为“脑残”的。发现自己崇拜的偶像、欣赏的前辈竟然是自己所鄙夷的那一类人，让我想起了之前知乎一位罗黑讲过的话：“有一种罗黑群体，他们是最早认识罗永浩的那一批人。”是啊，想想看，如果我是在那个时候认识的老罗，我也是确定无疑地会鄙夷反感这个人的吧。 回头看看自己崇拜的老罗，他的演讲堪称风趣风格的教科书级，他在工业设计上强调的工匠精神、精雕细琢，他在硬件、系统中推崇的完美主义、易用主义，他尊重知识产权，他支持开源世界，他身体力行地带着锤子科技改变了这个行业的一些风气，这些都是真实存在的。 再看看他曾经的一系列言论，那些也是真真切切被很多人看在眼里的。也许他已经慢慢改变了想法，不再是那个无脑的愤青喷子，又或许他只是现在作为企业家收敛了自己那些会带来负面效应的作为。其实我更相信后者，因为我不太相信一个中年人的三观会在几年内发生巨大改变。“脑残”的老罗，这也是真实的老罗。 说实话，我一直潜意识地认为老罗在其他方面也是同样美好同样堪称偶像，他热爱着手机行业，我就推断了他也热爱着自己的祖国。这听起来可笑，但它确实在我把老罗当做偶像时在脑海中发生了。我不禁开始想，我们对于偶像的崇拜，到底该持什么样的态度。到目前为止，我还确信，我一直喜欢的老罗的那些特质，都依然真实存在且值得推崇，在这些方面他依然是值得尊重的前辈。但是到了社会观的讨论上，他已经是一个我鄙夷厌恶的对象。这些冲突吗？也许冲突，因为这些让我无法再把他摆在偶像的位置上。但又不冲突，因为我欣赏他在手机行业的成就时无关于对三观的讨论。 归于一句话，我认为对于偶像的崇拜，不必强求他方方面面都值得学习。与此同时，一个人有令你惊叹的一面，不代表他方方面面都同样光芒四射。 所以，当你听说小A的偶像是林丹时，你不能因为林丹出轨就推断小A会对感情不忠，因为小A崇拜的只是林丹打球时的气概。]]></content>
    </entry>

    
  
  
</search>
